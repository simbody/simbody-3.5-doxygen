<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::Array_&lt; T, X &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Array__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1Array__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Array_&lt; T, X &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library (STL) std::vector&lt;T&gt; class, but with some important advantages in performance, and functionality, and binary compatibility.  
 <a href="classSimTK_1_1Array__.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Array_&lt; T, X &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Array__.png" usemap="#SimTK::Array_5F_3C_20T_2C_20X_20_3E_map" alt=""/>
  <map id="SimTK::Array_5F_3C_20T_2C_20X_20_3E_map" name="SimTK::Array_&lt; T, X &gt;_map">
<area href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t..." alt="SimTK::ArrayView_&lt; T, X &gt;" shape="rect" coords="0,56,202,80"/>
<area href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we..." alt="SimTK::ArrayViewConst_&lt; T, X &gt;" shape="rect" coords="0,0,202,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Types required of STL containers, plus index_type which is an extension, and packed_size_type which is an implementation detail.</p>
</div></td></tr>
<tr class="memitem:ac67020459c021a6a6e076839105b1dd8"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ac67020459c021a6a6e076839105b1dd8">value_type</a></td></tr>
<tr class="separator:ac67020459c021a6a6e076839105b1dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aed3ed93a6d406a35da0225352694b1"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3aed3ed93a6d406a35da0225352694b1">index_type</a></td></tr>
<tr class="separator:a3aed3ed93a6d406a35da0225352694b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe40f48092df9a7deafe32ef1ec39fb"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#adfe40f48092df9a7deafe32ef1ec39fb">pointer</a></td></tr>
<tr class="separator:adfe40f48092df9a7deafe32ef1ec39fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e344836dca88d0070ee505da9a628bb"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1e344836dca88d0070ee505da9a628bb">const_pointer</a></td></tr>
<tr class="separator:a1e344836dca88d0070ee505da9a628bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5efd5cd3092babe7a107b8efa664204"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ae5efd5cd3092babe7a107b8efa664204">reference</a></td></tr>
<tr class="separator:ae5efd5cd3092babe7a107b8efa664204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e967f4929d463e32202d34158f3e22f"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3e967f4929d463e32202d34158f3e22f">const_reference</a></td></tr>
<tr class="separator:a3e967f4929d463e32202d34158f3e22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05144fefe932d1c76e2e0dcaedddcd03"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a05144fefe932d1c76e2e0dcaedddcd03">iterator</a></td></tr>
<tr class="separator:a05144fefe932d1c76e2e0dcaedddcd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a140d8babac3edb92ff620e77245d0"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a47a140d8babac3edb92ff620e77245d0">const_iterator</a></td></tr>
<tr class="separator:a47a140d8babac3edb92ff620e77245d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9e2010641fb5df3c7e47c62a6db774"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a9a9e2010641fb5df3c7e47c62a6db774">reverse_iterator</a></td></tr>
<tr class="separator:a9a9e2010641fb5df3c7e47c62a6db774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b19c88ae09eec0ff5288e8e824d498"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a96b19c88ae09eec0ff5288e8e824d498">const_reverse_iterator</a></td></tr>
<tr class="separator:a96b19c88ae09eec0ff5288e8e824d498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed205f5372aad3ca9a8366441b16913"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913">size_type</a></td></tr>
<tr class="separator:a7ed205f5372aad3ca9a8366441b16913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5ca3b32f612044bed7552b7dc96164"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3a5ca3b32f612044bed7552b7dc96164">difference_type</a></td></tr>
<tr class="separator:a3a5ca3b32f612044bed7552b7dc96164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b7dc77f42cab3244ec808e5d4d3ee3"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ab1b7dc77f42cab3244ec808e5d4d3ee3">packed_size_type</a></td></tr>
<tr class="separator:ab1b7dc77f42cab3244ec808e5d4d3ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1ArrayView__"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1ArrayView__')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:aeb29ff328a71341945e442234f50e253 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aeb29ff328a71341945e442234f50e253">value_type</a></td></tr>
<tr class="separator:aeb29ff328a71341945e442234f50e253 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79baa909a71d2f8c75b1120776ccca3 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ae79baa909a71d2f8c75b1120776ccca3">index_type</a></td></tr>
<tr class="separator:ae79baa909a71d2f8c75b1120776ccca3 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3950fd72f5f77716f823f8c0a9a87974 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a3950fd72f5f77716f823f8c0a9a87974">pointer</a></td></tr>
<tr class="separator:a3950fd72f5f77716f823f8c0a9a87974 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e8dabb125276c7fcdaa215b23f808f inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad6e8dabb125276c7fcdaa215b23f808f">const_pointer</a></td></tr>
<tr class="separator:ad6e8dabb125276c7fcdaa215b23f808f inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b4b454ffabc27881011e3dcfea4014 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab4b4b454ffabc27881011e3dcfea4014">reference</a></td></tr>
<tr class="separator:ab4b4b454ffabc27881011e3dcfea4014 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611de0d81f0e43b256704e817d63ae47 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a611de0d81f0e43b256704e817d63ae47">const_reference</a></td></tr>
<tr class="separator:a611de0d81f0e43b256704e817d63ae47 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6566e08689eb53ae89a2b000ed4a4140 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a6566e08689eb53ae89a2b000ed4a4140">iterator</a></td></tr>
<tr class="separator:a6566e08689eb53ae89a2b000ed4a4140 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14185eed75d43f044775a366c02590c0 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a14185eed75d43f044775a366c02590c0">const_iterator</a></td></tr>
<tr class="separator:a14185eed75d43f044775a366c02590c0 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704e9c961a4621efd1bfe21bf099ca77 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a704e9c961a4621efd1bfe21bf099ca77">reverse_iterator</a></td></tr>
<tr class="separator:a704e9c961a4621efd1bfe21bf099ca77 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1232d267e9b8c139cca1512b412a6d1 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ac1232d267e9b8c139cca1512b412a6d1">const_reverse_iterator</a></td></tr>
<tr class="separator:ac1232d267e9b8c139cca1512b412a6d1 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e901cbddbca41c54b22c6216ac804b inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b">size_type</a></td></tr>
<tr class="separator:ab6e901cbddbca41c54b22c6216ac804b inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad962ee7e4110ac6c20bdfa340f81dc inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#abad962ee7e4110ac6c20bdfa340f81dc">difference_type</a></td></tr>
<tr class="separator:abad962ee7e4110ac6c20bdfa340f81dc inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9536141dcc61cfc646bb1f2062e5e558 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a9536141dcc61cfc646bb1f2062e5e558">packed_size_type</a></td></tr>
<tr class="separator:a9536141dcc61cfc646bb1f2062e5e558 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1ArrayViewConst__"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1ArrayViewConst__')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">value_type</a></td></tr>
<tr class="memdesc:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object stored in this container.  <a href="#a39bda86e859db1597f4d49d8037d0660">More...</a><br /></td></tr>
<tr class="separator:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a></td></tr>
<tr class="memdesc:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type (an extension).  <a href="#af92bca96f3089b5f0d4133fce9c7cded">More...</a><br /></td></tr>
<tr class="separator:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">pointer</a></td></tr>
<tr class="memdesc:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable pointer to a value_type.  <a href="#a2825bef320398cbf8d8f2e2b8631632e">More...</a><br /></td></tr>
<tr class="separator:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">const_pointer</a></td></tr>
<tr class="memdesc:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const pointer to a value_type.  <a href="#a7fdc551f402dc69766e819733ee6f08b">More...</a><br /></td></tr>
<tr class="separator:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">reference</a></td></tr>
<tr class="memdesc:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable value_type reference.  <a href="#aacce6f572b1deffcefa3f3aae5263b1c">More...</a><br /></td></tr>
<tr class="separator:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">const_reference</a></td></tr>
<tr class="memdesc:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const value_type reference.  <a href="#a460302f601c4a2c2d63837cb1e5d875a">More...</a><br /></td></tr>
<tr class="separator:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a></td></tr>
<tr class="memdesc:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable iterator for this container (same as pointer here).  <a href="#a416a8bff8ad197d4dfb2d41866acbd23">More...</a><br /></td></tr>
<tr class="separator:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a></td></tr>
<tr class="memdesc:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator for this container (same as const_pointer here).  <a href="#a76215b9c0677fca5706f11038f496963">More...</a><br /></td></tr>
<tr class="separator:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a></td></tr>
<tr class="memdesc:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable reverse iterator for this container.  <a href="#a4b566573f0b94c804a6b6e0514c78bce">More...</a><br /></td></tr>
<tr class="separator:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const reverse iterator for this container.  <a href="#ab26d002d51080ddd32f8899e5ea3ea40">More...</a><br /></td></tr>
<tr class="separator:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a></td></tr>
<tr class="memdesc:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integral type suitable for all indices and sizes for this array.  <a href="#abaaff64afd3daaed43f1acecbe2bbfe7">More...</a><br /></td></tr>
<tr class="separator:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a></td></tr>
<tr class="memdesc:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integral type that can represent the difference between any two legitimate index values for this array.  <a href="#a1f604d5e70ddbe7eb0bf9a80a236951e">More...</a><br /></td></tr>
<tr class="separator:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a></td></tr>
<tr class="memdesc:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integral type we actually use internally to store size_type values.  <a href="#af01fd47de6bffe601337c1ef0a45e88d">More...</a><br /></td></tr>
<tr class="separator:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, conversion and destruction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A variety of constructors are provided for this class, including all those required by the C++ standard for std::vector implementations, plus additional ones providing smooth conversions between Array_&lt;T&gt; and std::vector&lt;T&gt; objects. </p>
</div></td></tr>
<tr class="memitem:adc75b3e8df6112d5ea6fd77ad024bcc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#adc75b3e8df6112d5ea6fd77ad024bcc3">Array_</a> ()</td></tr>
<tr class="memdesc:adc75b3e8df6112d5ea6fd77ad024bcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="#adc75b3e8df6112d5ea6fd77ad024bcc3">More...</a><br /></td></tr>
<tr class="separator:adc75b3e8df6112d5ea6fd77ad024bcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9e625487e34b5255619a492514926d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7a9e625487e34b5255619a492514926d">Array_</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n)</td></tr>
<tr class="memdesc:a7a9e625487e34b5255619a492514926d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array containing <em>n</em> default-constructed elements.  <a href="#a7a9e625487e34b5255619a492514926d">More...</a><br /></td></tr>
<tr class="separator:a7a9e625487e34b5255619a492514926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad758f8ef3bb565989a22c5456a34f3b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad758f8ef3bb565989a22c5456a34f3b6">Array_</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;initVal)</td></tr>
<tr class="memdesc:ad758f8ef3bb565989a22c5456a34f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array containing <em>n</em> elements each set to a copy of the given initial value.  <a href="#ad758f8ef3bb565989a22c5456a34f3b6">More...</a><br /></td></tr>
<tr class="separator:ad758f8ef3bb565989a22c5456a34f3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730175ab17a18e5d87974ea97c712e3e"><td class="memTemplParams" colspan="2">template&lt;class InputIter &gt; </td></tr>
<tr class="memitem:a730175ab17a18e5d87974ea97c712e3e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a730175ab17a18e5d87974ea97c712e3e">Array_</a> (const InputIter &amp;first, const InputIter &amp;last1)</td></tr>
<tr class="memdesc:a730175ab17a18e5d87974ea97c712e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; from a range [first,last1) of values identified by a pair of iterators.  <a href="#a730175ab17a18e5d87974ea97c712e3e">More...</a><br /></td></tr>
<tr class="separator:a730175ab17a18e5d87974ea97c712e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782b385c4c710cf60fc4205371c7d5cc"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a782b385c4c710cf60fc4205371c7d5cc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a782b385c4c710cf60fc4205371c7d5cc">Array_</a> (const T2 *first, const T2 *last1)</td></tr>
<tr class="memdesc:a782b385c4c710cf60fc4205371c7d5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; from a range [first,last1) of values identified by a pair of ordinary pointers to elements of type T2 (where T2 might be the same as T but doesn't have to be).  <a href="#a782b385c4c710cf60fc4205371c7d5cc">More...</a><br /></td></tr>
<tr class="separator:a782b385c4c710cf60fc4205371c7d5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d3d7fccc13d4d892ce52ebccdf4acc"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a40d3d7fccc13d4d892ce52ebccdf4acc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a40d3d7fccc13d4d892ce52ebccdf4acc">Array_</a> (const std::vector&lt; T2 &gt; &amp;v)</td></tr>
<tr class="memdesc:a40d3d7fccc13d4d892ce52ebccdf4acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; by copying from an std::vector&lt;T2&gt;, where T2 may be the same type as T but doesn't have to be.  <a href="#a40d3d7fccc13d4d892ce52ebccdf4acc">More...</a><br /></td></tr>
<tr class="separator:a40d3d7fccc13d4d892ce52ebccdf4acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe60949157ed425b6b81b7ff0e11ca29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#afe60949157ed425b6b81b7ff0e11ca29">Array_</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;src)</td></tr>
<tr class="memdesc:afe60949157ed425b6b81b7ff0e11ca29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor allocates exactly as much memory as is in use in the source (not its capacity) and copy constructs the elements so that T's copy constructor will be called exactly src.size() times.  <a href="#afe60949157ed425b6b81b7ff0e11ca29">More...</a><br /></td></tr>
<tr class="separator:afe60949157ed425b6b81b7ff0e11ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66a2741c555a387d09742b9a5517314"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:af66a2741c555a387d09742b9a5517314"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af66a2741c555a387d09742b9a5517314">Array_</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:af66a2741c555a387d09742b9a5517314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this Array_&lt;T,X&gt; as a copy of another Array_&lt;T2,X2&gt; where T2!=T or X2!=X.  <a href="#af66a2741c555a387d09742b9a5517314">More...</a><br /></td></tr>
<tr class="separator:af66a2741c555a387d09742b9a5517314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d115efe0bc7dafba02b3d04562dd92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a53d115efe0bc7dafba02b3d04562dd92">Array_</a> (T *first, const T *last1, const <a class="el" href="structSimTK_1_1DontCopy.html">DontCopy</a> &amp;)</td></tr>
<tr class="memdesc:a53d115efe0bc7dafba02b3d04562dd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; by referencing (sharing) a given range of data [first,last1), without copying that data; better to use the corresponding ArrayView_&lt;T&gt; constructor if you can.  <a href="#a53d115efe0bc7dafba02b3d04562dd92">More...</a><br /></td></tr>
<tr class="separator:a53d115efe0bc7dafba02b3d04562dd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3331ee7155535eeac08b7297da16ebe3"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a3331ee7155535eeac08b7297da16ebe3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3331ee7155535eeac08b7297da16ebe3">Array_</a> (std::vector&lt; T, A &gt; &amp;v, const <a class="el" href="structSimTK_1_1DontCopy.html">DontCopy</a> &amp;)</td></tr>
<tr class="memdesc:a3331ee7155535eeac08b7297da16ebe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; by referencing (sharing) the data in an std::vector&lt;T&gt;, without copying the data; better to use the ArrayView_&lt;T&gt; constructor instead if you can.  <a href="#a3331ee7155535eeac08b7297da16ebe3">More...</a><br /></td></tr>
<tr class="separator:a3331ee7155535eeac08b7297da16ebe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55d3b71e2acdaa0f2bb8be2617c894f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad55d3b71e2acdaa0f2bb8be2617c894f">~Array_</a> ()</td></tr>
<tr class="memdesc:ad55d3b71e2acdaa0f2bb8be2617c894f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor performs a <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> operation which may result in element destruction and freeing of heap space; see <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> for more information.  <a href="#ad55d3b71e2acdaa0f2bb8be2617c894f">More...</a><br /></td></tr>
<tr class="separator:ad55d3b71e2acdaa0f2bb8be2617c894f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bc6c09d3ea513dfba42a5dfc42cd38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38">deallocate</a> ()</td></tr>
<tr class="memdesc:a67bc6c09d3ea513dfba42a5dfc42cd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty this array of its contents, returning the array to its default-constructed, all-zero state.  <a href="#a67bc6c09d3ea513dfba42a5dfc42cd38">More...</a><br /></td></tr>
<tr class="separator:a67bc6c09d3ea513dfba42a5dfc42cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment methods and operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods put new data values in an existing array, but the meaning of assignment is subtly different for resizeable (owner) arrays and fixed (non-owner) arrays.</p>
<p>The standard std::vector type is always an owner so the non-owner description here is an extension applying only to <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>.</p>
<p>For the normal case of resizeable arrays, assignment does not have an elementwise definition because the source will typically have a different number of elements than the array's current size. So regardless of the actual numbers, assignment in the resizeable case is defined as it is for std::vector: first clear the array by erasing (destructing) all the current elements in the array, then reserve sufficient heap space to hold a copy of the source, then use appropriate constructors of type T (most commonly T's copy constructor T(T)) to initialize each element to be a copy of the corresponding source element. T's assignment operators are never used in this case.</p>
<p>For fixed arrays, the source must have the same number of elments as are currently in the array and the meaning is conventional elementwise assignment; that is, an appropriate assignment operator of type T (most commonly T's copy assignment operator T=T) is used to change the value of each existing element.</p>
<p>So there are different requirements on the value type T for owner and non-owner assignments to type T2: for owner assignment T must have a constructor T(T2) available; for non-owner assignment, T must have an assignment operator T=T2 available; .</p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>When reallocating the destination array, we may reuse the existing heap allocation if it is sufficient and not <em>too</em> big; otherwise we'll reallocate before copying.</li>
<li>The <a class="el" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab" title="Assign all current elements of the array to the same fillValue. ">fill()</a> method here has elementwise assignment semantics regardless of whether the array is an owner or non-owner. </li>
</ul>
</dd></dl>
</div></td></tr>
<tr class="memitem:a136a03677c28d7ee697df7e09b7aa2e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a136a03677c28d7ee697df7e09b7aa2e2">assign</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;fillValue)</td></tr>
<tr class="memdesc:a136a03677c28d7ee697df7e09b7aa2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this array to be <em>n</em> copies of the supplied <em>fillValue</em>.  <a href="#a136a03677c28d7ee697df7e09b7aa2e2">More...</a><br /></td></tr>
<tr class="separator:a136a03677c28d7ee697df7e09b7aa2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc4a2796075ec7a3097bcc6d616bab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab">fill</a> (const T &amp;fillValue)</td></tr>
<tr class="memdesc:a66cc4a2796075ec7a3097bcc6d616bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign all current elements of the array to the same <em>fillValue</em>.  <a href="#a66cc4a2796075ec7a3097bcc6d616bab">More...</a><br /></td></tr>
<tr class="separator:a66cc4a2796075ec7a3097bcc6d616bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1614ce819a2a4221c0a072ffbc2a0935"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a1614ce819a2a4221c0a072ffbc2a0935"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1614ce819a2a4221c0a072ffbc2a0935">assign</a> (const T2 *first, const T2 *last1)</td></tr>
<tr class="memdesc:a1614ce819a2a4221c0a072ffbc2a0935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to this array to to make it a copy of the elements in range [first,last1) given by ordinary pointers.  <a href="#a1614ce819a2a4221c0a072ffbc2a0935">More...</a><br /></td></tr>
<tr class="separator:a1614ce819a2a4221c0a072ffbc2a0935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fbbed70bc0fdb3ec5c188193503bb8"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ab0fbbed70bc0fdb3ec5c188193503bb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ab0fbbed70bc0fdb3ec5c188193503bb8">assign</a> (const Iter &amp;first, const Iter &amp;last1)</td></tr>
<tr class="memdesc:ab0fbbed70bc0fdb3ec5c188193503bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this array from a range [first,last1) given by non-pointer iterators.  <a href="#ab0fbbed70bc0fdb3ec5c188193503bb8">More...</a><br /></td></tr>
<tr class="separator:ab0fbbed70bc0fdb3ec5c188193503bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17aa8ec53fbbd5af9d8311040b4e215a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a17aa8ec53fbbd5af9d8311040b4e215a">operator=</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;src)</td></tr>
<tr class="memdesc:a17aa8ec53fbbd5af9d8311040b4e215a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator destructs the current contents of this array and then makes it a copy of the source array by repeated calls to the element type's copy constructor.  <a href="#a17aa8ec53fbbd5af9d8311040b4e215a">More...</a><br /></td></tr>
<tr class="separator:a17aa8ec53fbbd5af9d8311040b4e215a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31782606c119d1db301ef14a930abd22"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a31782606c119d1db301ef14a930abd22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a31782606c119d1db301ef14a930abd22">operator=</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a31782606c119d1db301ef14a930abd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is assignment from a source array whose element type T2 and/or index type X2 are different from this array's T and X.  <a href="#a31782606c119d1db301ef14a930abd22">More...</a><br /></td></tr>
<tr class="separator:a31782606c119d1db301ef14a930abd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abada82afde9d55dbde8b44052ce1fda1"><td class="memTemplParams" colspan="2">template&lt;class T2 , class A &gt; </td></tr>
<tr class="memitem:abada82afde9d55dbde8b44052ce1fda1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#abada82afde9d55dbde8b44052ce1fda1">operator=</a> (const std::vector&lt; T2, A &gt; &amp;src)</td></tr>
<tr class="memdesc:abada82afde9d55dbde8b44052ce1fda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is assignment from a source std::vector&lt;T2&gt;.  <a href="#abada82afde9d55dbde8b44052ce1fda1">More...</a><br /></td></tr>
<tr class="separator:abada82afde9d55dbde8b44052ce1fda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c544ef3a4eee81c7580699e793e0f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a4c544ef3a4eee81c7580699e793e0f92">swap</a> (<a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;other)</td></tr>
<tr class="memdesc:a4c544ef3a4eee81c7580699e793e0f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a specialized algorithm providing constant time exchange of data with another array that has identical element and index types.  <a href="#a4c544ef3a4eee81c7580699e793e0f92">More...</a><br /></td></tr>
<tr class="separator:a4c544ef3a4eee81c7580699e793e0f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5671ab71d22a14e65a149feea9c577a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a">adoptData</a> (T *newData, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> dataSize, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> dataCapacity)</td></tr>
<tr class="memdesc:ac5671ab71d22a14e65a149feea9c577a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This dangerous extension allows you to supply your own already-allocated heap space for use by this array, which then becomes the owner of the supplied heap space.  <a href="#ac5671ab71d22a14e65a149feea9c577a">More...</a><br /></td></tr>
<tr class="separator:ac5671ab71d22a14e65a149feea9c577a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37550aafe7e3c54f9604ff80479153e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a37550aafe7e3c54f9604ff80479153e9">adoptData</a> (T *newData, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> dataSize)</td></tr>
<tr class="memdesc:a37550aafe7e3c54f9604ff80479153e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a" title="This dangerous extension allows you to supply your own already-allocated heap space for use by this a...">adoptData()</a> that assumes the capacity is the same as the current size.  <a href="#a37550aafe7e3c54f9604ff80479153e9">More...</a><br /></td></tr>
<tr class="separator:a37550aafe7e3c54f9604ff80479153e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e51e9d13453755cb0cce47af007d3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3e51e9d13453755cb0cce47af007d3c7">shareData</a> (T *newData, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> dataSize)</td></tr>
<tr class="memdesc:a3e51e9d13453755cb0cce47af007d3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This dangerous extension allows you to make this array handle refer to someone else's data without copying it.  <a href="#a3e51e9d13453755cb0cce47af007d3c7">More...</a><br /></td></tr>
<tr class="separator:a3e51e9d13453755cb0cce47af007d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa780ca6f8edd609cd461b0a90fbbca64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa780ca6f8edd609cd461b0a90fbbca64">shareData</a> (T *first, const T *last1)</td></tr>
<tr class="memdesc:aa780ca6f8edd609cd461b0a90fbbca64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as shareData(data,size) but uses a pointer range [first,last1) to identify the data to be referenced.  <a href="#aa780ca6f8edd609cd461b0a90fbbca64">More...</a><br /></td></tr>
<tr class="separator:aa780ca6f8edd609cd461b0a90fbbca64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and capacity</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods examine and alter the number of elements (size) or the amount of allocated heap space (capacity) or both.</p>
</div></td></tr>
<tr class="memitem:a00d92f7cb1c2c6ad7d8ff7267a67ee0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a">size</a> () const </td></tr>
<tr class="memdesc:a00d92f7cb1c2c6ad7d8ff7267a67ee0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current number of elements stored in this array.  <a href="#a00d92f7cb1c2c6ad7d8ff7267a67ee0a">More...</a><br /></td></tr>
<tr class="separator:a00d92f7cb1c2c6ad7d8ff7267a67ee0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f29e36968740e433a451cb82774046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046">max_size</a> () const </td></tr>
<tr class="memdesc:aa7f29e36968740e433a451cb82774046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowable size for this array.  <a href="#aa7f29e36968740e433a451cb82774046">More...</a><br /></td></tr>
<tr class="separator:aa7f29e36968740e433a451cb82774046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c0aa10d7095ff4a6c385a5f408b170"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a41c0aa10d7095ff4a6c385a5f408b170">empty</a> () const </td></tr>
<tr class="memdesc:a41c0aa10d7095ff4a6c385a5f408b170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no elements currently stored in this array.  <a href="#a41c0aa10d7095ff4a6c385a5f408b170">More...</a><br /></td></tr>
<tr class="separator:a41c0aa10d7095ff4a6c385a5f408b170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d905825b941637a97453cba165f0feb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb">capacity</a> () const </td></tr>
<tr class="memdesc:a7d905825b941637a97453cba165f0feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements this array can currently hold without requiring reallocation.  <a href="#a7d905825b941637a97453cba165f0feb">More...</a><br /></td></tr>
<tr class="separator:a7d905825b941637a97453cba165f0feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef48cf9aac351db79f747c2ddd23bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3ef48cf9aac351db79f747c2ddd23bf4">resize</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n)</td></tr>
<tr class="memdesc:a3ef48cf9aac351db79f747c2ddd23bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of this Array, preserving all the elements that will still fit, and default constructing any new elements that are added.  <a href="#a3ef48cf9aac351db79f747c2ddd23bf4">More...</a><br /></td></tr>
<tr class="separator:a3ef48cf9aac351db79f747c2ddd23bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab839b023c760816f9580d4feea2c9136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ab839b023c760816f9580d4feea2c9136">resize</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;initVal)</td></tr>
<tr class="memdesc:ab839b023c760816f9580d4feea2c9136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of this array, preserving all the elements that will still fit, and initializing any new elements that are added by repeatedly copy- constructing from the supplied value.  <a href="#ab839b023c760816f9580d4feea2c9136">More...</a><br /></td></tr>
<tr class="separator:ab839b023c760816f9580d4feea2c9136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b9cb15ea07f2da45d9b45a8f12429e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a18b9cb15ea07f2da45d9b45a8f12429e">reserve</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n)</td></tr>
<tr class="memdesc:a18b9cb15ea07f2da45d9b45a8f12429e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that this array has enough allocated capacity to hold the indicated number of elements.  <a href="#a18b9cb15ea07f2da45d9b45a8f12429e">More...</a><br /></td></tr>
<tr class="separator:a18b9cb15ea07f2da45d9b45a8f12429e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5af2017b0c5a1a2160104d98a59294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aad5af2017b0c5a1a2160104d98a59294">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:aad5af2017b0c5a1a2160104d98a59294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the capacity of this array be reduced to the minimum necessary to hold the number of elements currently in use.  <a href="#aad5af2017b0c5a1a2160104d98a59294">More...</a><br /></td></tr>
<tr class="separator:aad5af2017b0c5a1a2160104d98a59294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09f12c0986ba2025ece82fa7fe5df41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41">allocated</a> () const </td></tr>
<tr class="memdesc:ab09f12c0986ba2025ece82fa7fe5df41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amount of heap space owned by this array; this is the same as <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> for owner arrays but is zero for non-owners.  <a href="#ab09f12c0986ba2025ece82fa7fe5df41">More...</a><br /></td></tr>
<tr class="separator:ab09f12c0986ba2025ece82fa7fe5df41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f384696e84727ee28902212fc95a1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d">isOwner</a> () const </td></tr>
<tr class="memdesc:a82f384696e84727ee28902212fc95a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this array own the data to which it refers? If not, it can't be resized, and the destructor will not free any heap space nor call any element destructors.  <a href="#a82f384696e84727ee28902212fc95a1d">More...</a><br /></td></tr>
<tr class="separator:a82f384696e84727ee28902212fc95a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods deal in iterators, which are STL generalized pointers.</p>
<p>For this class, iterators are just ordinary pointers to T, and you may depend on that. By necessity, reverse iterators can't be just pointers; however, they contain an ordinary iterator (i.e. a pointer) that can be obtained by calling the reverse iterator's base() method. </p>
</div></td></tr>
<tr class="memitem:a1f009675fdf90d112f15279b35da6688"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1f009675fdf90d112f15279b35da6688">cbegin</a> () const </td></tr>
<tr class="memdesc:a1f009675fdf90d112f15279b35da6688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>, which may be null (0) in that case but does not have to be.  <a href="#a1f009675fdf90d112f15279b35da6688">More...</a><br /></td></tr>
<tr class="separator:a1f009675fdf90d112f15279b35da6688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b25d6dc2485899425d6a4c96d574ed0"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0">begin</a> () const </td></tr>
<tr class="memdesc:a8b25d6dc2485899425d6a4c96d574ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#a1f009675fdf90d112f15279b35da6688" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a>.  <a href="#a8b25d6dc2485899425d6a4c96d574ed0">More...</a><br /></td></tr>
<tr class="separator:a8b25d6dc2485899425d6a4c96d574ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87a252bd681eeb8d9e4075343263f1f"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f">begin</a> ()</td></tr>
<tr class="memdesc:ab87a252bd681eeb8d9e4075343263f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>.  <a href="#ab87a252bd681eeb8d9e4075343263f1f">More...</a><br /></td></tr>
<tr class="separator:ab87a252bd681eeb8d9e4075343263f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3758a3dc3ecebc1eeea89d389c049253"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253">cend</a> () const </td></tr>
<tr class="memdesc:a3758a3dc3ecebc1eeea89d389c049253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="#a3758a3dc3ecebc1eeea89d389c049253">More...</a><br /></td></tr>
<tr class="separator:a3758a3dc3ecebc1eeea89d389c049253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a9152d785cb3d350e624d53d49af08"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08">end</a> () const </td></tr>
<tr class="memdesc:a06a9152d785cb3d350e624d53d49af08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="#a06a9152d785cb3d350e624d53d49af08">More...</a><br /></td></tr>
<tr class="separator:a06a9152d785cb3d350e624d53d49af08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a12efc66437667e7af14e54747433ec"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec">end</a> ()</td></tr>
<tr class="memdesc:a5a12efc66437667e7af14e54747433ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to what would be the element just after the last one in this array.  <a href="#a5a12efc66437667e7af14e54747433ec">More...</a><br /></td></tr>
<tr class="separator:a5a12efc66437667e7af14e54747433ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f884619b7afeb2c4e31be0ac9a5c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af9f884619b7afeb2c4e31be0ac9a5c96">crbegin</a> () const </td></tr>
<tr class="memdesc:af9f884619b7afeb2c4e31be0ac9a5c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1Array__.html#a936220808b01ffe9e5080cf97cf67409" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="#af9f884619b7afeb2c4e31be0ac9a5c96">More...</a><br /></td></tr>
<tr class="separator:af9f884619b7afeb2c4e31be0ac9a5c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a9b5657f95c864088caa629bbb14c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a09a9b5657f95c864088caa629bbb14c8">rbegin</a> () const </td></tr>
<tr class="memdesc:a09a9b5657f95c864088caa629bbb14c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1Array__.html#aab002eb8f193aea7d6b4ab3683ff89aa" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#af9f884619b7afeb2c4e31be0ac9a5c96" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="#a09a9b5657f95c864088caa629bbb14c8">More...</a><br /></td></tr>
<tr class="separator:a09a9b5657f95c864088caa629bbb14c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab002eb8f193aea7d6b4ab3683ff89aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aab002eb8f193aea7d6b4ab3683ff89aa">rbegin</a> ()</td></tr>
<tr class="memdesc:aab002eb8f193aea7d6b4ab3683ff89aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> if the array is empty.  <a href="#aab002eb8f193aea7d6b4ab3683ff89aa">More...</a><br /></td></tr>
<tr class="separator:aab002eb8f193aea7d6b4ab3683ff89aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936220808b01ffe9e5080cf97cf67409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a936220808b01ffe9e5080cf97cf67409">crend</a> () const </td></tr>
<tr class="memdesc:a936220808b01ffe9e5080cf97cf67409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#a936220808b01ffe9e5080cf97cf67409">More...</a><br /></td></tr>
<tr class="separator:a936220808b01ffe9e5080cf97cf67409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6614217a1df42b91aa38cb3ea7ec61d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af6614217a1df42b91aa38cb3ea7ec61d">rend</a> () const </td></tr>
<tr class="memdesc:af6614217a1df42b91aa38cb3ea7ec61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#a936220808b01ffe9e5080cf97cf67409" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="#af6614217a1df42b91aa38cb3ea7ec61d">More...</a><br /></td></tr>
<tr class="separator:af6614217a1df42b91aa38cb3ea7ec61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5973f198607a6531235df6877ab9979d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d">rend</a> ()</td></tr>
<tr class="memdesc:a5973f198607a6531235df6877ab9979d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#a5973f198607a6531235df6877ab9979d">More...</a><br /></td></tr>
<tr class="separator:a5973f198607a6531235df6877ab9979d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9ac236751f99b1663c504ae87d3a2b"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ace9ac236751f99b1663c504ae87d3a2b">cdata</a> () const </td></tr>
<tr class="memdesc:ace9ac236751f99b1663c504ae87d3a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="#ace9ac236751f99b1663c504ae87d3a2b">More...</a><br /></td></tr>
<tr class="separator:ace9ac236751f99b1663c504ae87d3a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd7415f4c933c8c572d93b486193c26"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26">data</a> () const </td></tr>
<tr class="memdesc:aecd7415f4c933c8c572d93b486193c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1Array__.html#af05128fb7611eb19f884b1e742878277" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is identical to <a class="el" href="classSimTK_1_1Array__.html#ace9ac236751f99b1663c504ae87d3a2b" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="#aecd7415f4c933c8c572d93b486193c26">More...</a><br /></td></tr>
<tr class="separator:aecd7415f4c933c8c572d93b486193c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05128fb7611eb19f884b1e742878277"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af05128fb7611eb19f884b1e742878277">data</a> ()</td></tr>
<tr class="memdesc:af05128fb7611eb19f884b1e742878277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first allocated element of the array, or a null pointer if no space is associated with the array.  <a href="#af05128fb7611eb19f884b1e742878277">More...</a><br /></td></tr>
<tr class="separator:af05128fb7611eb19f884b1e742878277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide read and write access to individual elements, or groups of elements, that are currently present in the array.</p>
</div></td></tr>
<tr class="memitem:ac6db339c90590b6a6c230c2ebaa63141"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ac6db339c90590b6a6c230c2ebaa63141">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:ac6db339c90590b6a6c230c2ebaa63141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="#ac6db339c90590b6a6c230c2ebaa63141">More...</a><br /></td></tr>
<tr class="separator:ac6db339c90590b6a6c230c2ebaa63141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dc3c8d6816f2cc3d9e42caa2688993"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a52dc3c8d6816f2cc3d9e42caa2688993">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:a52dc3c8d6816f2cc3d9e42caa2688993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a writable (lvalue) reference.  <a href="#a52dc3c8d6816f2cc3d9e42caa2688993">More...</a><br /></td></tr>
<tr class="separator:a52dc3c8d6816f2cc3d9e42caa2688993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62d24dae1b22b621da114318134d55e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ab62d24dae1b22b621da114318134d55e">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:ab62d24dae1b22b621da114318134d55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#ab62d24dae1b22b621da114318134d55e">More...</a><br /></td></tr>
<tr class="separator:ab62d24dae1b22b621da114318134d55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a43460f045aeb40cc0e1ca44aacbc1"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa8a43460f045aeb40cc0e1ca44aacbc1">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:aa8a43460f045aeb40cc0e1ca44aacbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#aa8a43460f045aeb40cc0e1ca44aacbc1">More...</a><br /></td></tr>
<tr class="separator:aa8a43460f045aeb40cc0e1ca44aacbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e442e44a784734db4d3750c24d17ac1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a9e442e44a784734db4d3750c24d17ac1">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a9e442e44a784734db4d3750c24d17ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#a9e442e44a784734db4d3750c24d17ac1">More...</a><br /></td></tr>
<tr class="separator:a9e442e44a784734db4d3750c24d17ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17ec9fa947bdc8b7aa75a0d09b36214"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa17ec9fa947bdc8b7aa75a0d09b36214">updElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:aa17ec9fa947bdc8b7aa75a0d09b36214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the non-const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#aa17ec9fa947bdc8b7aa75a0d09b36214">More...</a><br /></td></tr>
<tr class="separator:aa17ec9fa947bdc8b7aa75a0d09b36214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d24987c3a2d57c2ceb5e0d3f15f73b7"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8d24987c3a2d57c2ceb5e0d3f15f73b7">front</a> () const </td></tr>
<tr class="memdesc:a8d24987c3a2d57c2ceb5e0d3f15f73b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty.  <a href="#a8d24987c3a2d57c2ceb5e0d3f15f73b7">More...</a><br /></td></tr>
<tr class="separator:a8d24987c3a2d57c2ceb5e0d3f15f73b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e306ed9d706676046787b8f8c049480"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3e306ed9d706676046787b8f8c049480">front</a> ()</td></tr>
<tr class="memdesc:a3e306ed9d706676046787b8f8c049480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the first element in this array, which must not be empty.  <a href="#a3e306ed9d706676046787b8f8c049480">More...</a><br /></td></tr>
<tr class="separator:a3e306ed9d706676046787b8f8c049480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251212be7a0d7adaa5f9f72d8a694a64"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a251212be7a0d7adaa5f9f72d8a694a64">back</a> () const </td></tr>
<tr class="memdesc:a251212be7a0d7adaa5f9f72d8a694a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty.  <a href="#a251212be7a0d7adaa5f9f72d8a694a64">More...</a><br /></td></tr>
<tr class="separator:a251212be7a0d7adaa5f9f72d8a694a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af001d2418473e4e149969b0aea2ac96a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af001d2418473e4e149969b0aea2ac96a">back</a> ()</td></tr>
<tr class="memdesc:af001d2418473e4e149969b0aea2ac96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the last element in this array, which must not be empty.  <a href="#af001d2418473e4e149969b0aea2ac96a">More...</a><br /></td></tr>
<tr class="separator:af001d2418473e4e149969b0aea2ac96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a623121405c9896be85477f4cb4953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a88a623121405c9896be85477f4cb4953">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const </td></tr>
<tr class="memdesc:a88a623121405c9896be85477f4cb4953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a subrange of this const array by starting index and length, and return a <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> referencing that data without copying it.  <a href="#a88a623121405c9896be85477f4cb4953">More...</a><br /></td></tr>
<tr class="separator:a88a623121405c9896be85477f4cb4953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8471d7b2c924d3704fbd54ab10451c19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8471d7b2c924d3704fbd54ab10451c19">getSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const </td></tr>
<tr class="memdesc:a8471d7b2c924d3704fbd54ab10451c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const form of operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="#a8471d7b2c924d3704fbd54ab10451c19">More...</a><br /></td></tr>
<tr class="separator:a8471d7b2c924d3704fbd54ab10451c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd317755142dd7707305ba1dd36c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a9cbd317755142dd7707305ba1dd36c4b">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:a9cbd317755142dd7707305ba1dd36c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a subrange of this array by starting index and length, and return an <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> referencing that data without copying it.  <a href="#a9cbd317755142dd7707305ba1dd36c4b">More...</a><br /></td></tr>
<tr class="separator:a9cbd317755142dd7707305ba1dd36c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223502957a0d38152ea9bda9ac194829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a223502957a0d38152ea9bda9ac194829">updSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:a223502957a0d38152ea9bda9ac194829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as non-const operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="#a223502957a0d38152ea9bda9ac194829">More...</a><br /></td></tr>
<tr class="separator:a223502957a0d38152ea9bda9ac194829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1ArrayView__"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1ArrayView__')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:aa8e89ce2da1f241ae70e38cfe63ba980 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa8e89ce2da1f241ae70e38cfe63ba980">ArrayView_</a> ()</td></tr>
<tr class="memdesc:aa8e89ce2da1f241ae70e38cfe63ba980 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="#aa8e89ce2da1f241ae70e38cfe63ba980">More...</a><br /></td></tr>
<tr class="separator:aa8e89ce2da1f241ae70e38cfe63ba980 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ddf75311833fc599a934c3f3d5a57d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad1ddf75311833fc599a934c3f3d5a57d">ArrayView_</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;src)</td></tr>
<tr class="memdesc:ad1ddf75311833fc599a934c3f3d5a57d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow.  <a href="#ad1ddf75311833fc599a934c3f3d5a57d">More...</a><br /></td></tr>
<tr class="separator:ad1ddf75311833fc599a934c3f3d5a57d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6104f869055379b0fbd146aeefa919 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a8e6104f869055379b0fbd146aeefa919">ArrayView_</a> (T *first, const T *last1)</td></tr>
<tr class="memdesc:a8e6104f869055379b0fbd146aeefa919 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a range of writable memory.  <a href="#a8e6104f869055379b0fbd146aeefa919">More...</a><br /></td></tr>
<tr class="separator:a8e6104f869055379b0fbd146aeefa919 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176653cfecc6ee9dd5cbb08f53725a34 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a176653cfecc6ee9dd5cbb08f53725a34 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a176653cfecc6ee9dd5cbb08f53725a34">ArrayView_</a> (std::vector&lt; T, A &gt; &amp;v)</td></tr>
<tr class="memdesc:a176653cfecc6ee9dd5cbb08f53725a34 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct to reference memory owned by a writable std::vector.  <a href="#a176653cfecc6ee9dd5cbb08f53725a34">More...</a><br /></td></tr>
<tr class="separator:a176653cfecc6ee9dd5cbb08f53725a34 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee82e038ccd001ede9b1104969fdfa3c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aee82e038ccd001ede9b1104969fdfa3c">operator const Array_&lt; T, X &gt; &amp;</a> () const </td></tr>
<tr class="memdesc:aee82e038ccd001ede9b1104969fdfa3c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion of const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to const <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; (zero cost).  <a href="#aee82e038ccd001ede9b1104969fdfa3c">More...</a><br /></td></tr>
<tr class="separator:aee82e038ccd001ede9b1104969fdfa3c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7f785e236628b37192a5380d0a479 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a6ef7f785e236628b37192a5380d0a479">operator Array_&lt; T, X &gt; &amp;</a> ()</td></tr>
<tr class="memdesc:a6ef7f785e236628b37192a5380d0a479 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion of non-const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; (zero cost).  <a href="#a6ef7f785e236628b37192a5380d0a479">More...</a><br /></td></tr>
<tr class="separator:a6ef7f785e236628b37192a5380d0a479 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7848acb2e30474663b3d708e80f2b6bc inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc">disconnect</a> ()</td></tr>
<tr class="memdesc:a7848acb2e30474663b3d708e80f2b6bc inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward to base class <a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc" title="Forward to base class disconnect() method  clears the handle without doing anything to the data...">disconnect()</a> method &ndash; clears the handle without doing anything to the data.  <a href="#a7848acb2e30474663b3d708e80f2b6bc">More...</a><br /></td></tr>
<tr class="separator:a7848acb2e30474663b3d708e80f2b6bc inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509b38ff0b42a6ff6b38cd3b26f4096f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a509b38ff0b42a6ff6b38cd3b26f4096f">~ArrayView_</a> ()</td></tr>
<tr class="memdesc:a509b38ff0b42a6ff6b38cd3b26f4096f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">ArrayViewConst_&lt;T,X&gt;::disconnect()</a> for more information.  <a href="#a509b38ff0b42a6ff6b38cd3b26f4096f">More...</a><br /></td></tr>
<tr class="separator:a509b38ff0b42a6ff6b38cd3b26f4096f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3e84580379c69d92ab24d96fa6c180 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;src)</td></tr>
<tr class="memdesc:a1a3e84580379c69d92ab24d96fa6c180 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment; source must be the same size as this array.  <a href="#a1a3e84580379c69d92ab24d96fa6c180">More...</a><br /></td></tr>
<tr class="separator:a1a3e84580379c69d92ab24d96fa6c180 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8826e1792377e63d47b9c9a3c53584 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a7f8826e1792377e63d47b9c9a3c53584 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a7f8826e1792377e63d47b9c9a3c53584">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a7f8826e1792377e63d47b9c9a3c53584 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="#a7f8826e1792377e63d47b9c9a3c53584">More...</a><br /></td></tr>
<tr class="separator:a7f8826e1792377e63d47b9c9a3c53584 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5dc46e5a1126a8e30882e53a86c62d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:acb5dc46e5a1126a8e30882e53a86c62d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acb5dc46e5a1126a8e30882e53a86c62d">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:acb5dc46e5a1126a8e30882e53a86c62d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="#acb5dc46e5a1126a8e30882e53a86c62d">More...</a><br /></td></tr>
<tr class="separator:acb5dc46e5a1126a8e30882e53a86c62d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bc77b91b7751a909ca6524346c9e8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a45bc77b91b7751a909ca6524346c9e8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a45bc77b91b7751a909ca6524346c9e8d">operator=</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a45bc77b91b7751a909ca6524346c9e8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="#a45bc77b91b7751a909ca6524346c9e8d">More...</a><br /></td></tr>
<tr class="separator:a45bc77b91b7751a909ca6524346c9e8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68daffa0f934e5f3d6f75adcb5d93367 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T2 , class A2 &gt; </td></tr>
<tr class="memitem:a68daffa0f934e5f3d6f75adcb5d93367 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a68daffa0f934e5f3d6f75adcb5d93367">operator=</a> (const std::vector&lt; T2, A2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a68daffa0f934e5f3d6f75adcb5d93367 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any std::vector object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="#a68daffa0f934e5f3d6f75adcb5d93367">More...</a><br /></td></tr>
<tr class="separator:a68daffa0f934e5f3d6f75adcb5d93367 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e6a21ecbf455765267d5d12bde8628 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a29e6a21ecbf455765267d5d12bde8628">operator=</a> (const T &amp;fillValue)</td></tr>
<tr class="memdesc:a29e6a21ecbf455765267d5d12bde8628 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill assignment &ndash; all elements are set to fillValue.  <a href="#a29e6a21ecbf455765267d5d12bde8628">More...</a><br /></td></tr>
<tr class="separator:a29e6a21ecbf455765267d5d12bde8628 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbebca5377888478d004f882a6c24e2 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2">fill</a> (const T &amp;fillValue)</td></tr>
<tr class="memdesc:a1dbebca5377888478d004f882a6c24e2 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the supplied fill value to each element of this array, using T's copy assignment operator for each element.  <a href="#a1dbebca5377888478d004f882a6c24e2">More...</a><br /></td></tr>
<tr class="separator:a1dbebca5377888478d004f882a6c24e2 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a7d28c5d7a0586b39260b4a167f10c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c">assign</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;fillValue)</td></tr>
<tr class="memdesc:a06a7d28c5d7a0586b39260b4a167f10c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill()</a> but has the usual std::vector signature for compatibility; it will only work if the given number of elements is the same as this array's (fixed) size.  <a href="#a06a7d28c5d7a0586b39260b4a167f10c">More...</a><br /></td></tr>
<tr class="separator:a06a7d28c5d7a0586b39260b4a167f10c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39312ebedf1ce457f129b39c69d4515a inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a39312ebedf1ce457f129b39c69d4515a inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a39312ebedf1ce457f129b39c69d4515a">assign</a> (const T2 *first, const T2 *last1)</td></tr>
<tr class="memdesc:a39312ebedf1ce457f129b39c69d4515a inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to this array to make it a copy of the elements in range [first,last1) given by ordinary pointers, provided that the range is the same size as the array.  <a href="#a39312ebedf1ce457f129b39c69d4515a">More...</a><br /></td></tr>
<tr class="separator:a39312ebedf1ce457f129b39c69d4515a inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c2516d03bb21d24ea4e87af777136 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:afb5c2516d03bb21d24ea4e87af777136 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#afb5c2516d03bb21d24ea4e87af777136">assign</a> (const Iter &amp;first, const Iter &amp;last1)</td></tr>
<tr class="memdesc:afb5c2516d03bb21d24ea4e87af777136 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to this array to make it a copy of the elements in range [first,last1) given by non-pointer iterators (the pointer case is handled with a specialized <a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign()</a> variant).  <a href="#afb5c2516d03bb21d24ea4e87af777136">More...</a><br /></td></tr>
<tr class="separator:afb5c2516d03bb21d24ea4e87af777136 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1802aff86a94788eab5bf63e5fd704df inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1802aff86a94788eab5bf63e5fd704df">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a1802aff86a94788eab5bf63e5fd704df inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="#a1802aff86a94788eab5bf63e5fd704df">More...</a><br /></td></tr>
<tr class="separator:a1802aff86a94788eab5bf63e5fd704df inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943c9a87081523151ddbf1d22a853e4e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a943c9a87081523151ddbf1d22a853e4e">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:a943c9a87081523151ddbf1d22a853e4e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a writable (lvalue) reference.  <a href="#a943c9a87081523151ddbf1d22a853e4e">More...</a><br /></td></tr>
<tr class="separator:a943c9a87081523151ddbf1d22a853e4e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cae4892293f33c0ffb5e615beda7a5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a99cae4892293f33c0ffb5e615beda7a5">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a99cae4892293f33c0ffb5e615beda7a5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#a99cae4892293f33c0ffb5e615beda7a5">More...</a><br /></td></tr>
<tr class="separator:a99cae4892293f33c0ffb5e615beda7a5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93f3650f5d31037f0051431eb02b57b inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab93f3650f5d31037f0051431eb02b57b">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:ab93f3650f5d31037f0051431eb02b57b inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#ab93f3650f5d31037f0051431eb02b57b">More...</a><br /></td></tr>
<tr class="separator:ab93f3650f5d31037f0051431eb02b57b inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9514b4dc81e3aee1fcf2d5b8acc3973 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ae9514b4dc81e3aee1fcf2d5b8acc3973">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:ae9514b4dc81e3aee1fcf2d5b8acc3973 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#ae9514b4dc81e3aee1fcf2d5b8acc3973">More...</a><br /></td></tr>
<tr class="separator:ae9514b4dc81e3aee1fcf2d5b8acc3973 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538c58736523ef56cafe9d926ec6e8f5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a538c58736523ef56cafe9d926ec6e8f5">updElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:a538c58736523ef56cafe9d926ec6e8f5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the non-const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#a538c58736523ef56cafe9d926ec6e8f5">More...</a><br /></td></tr>
<tr class="separator:a538c58736523ef56cafe9d926ec6e8f5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95912a09cf7bd29259ef8d4473720424 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a95912a09cf7bd29259ef8d4473720424">front</a> () const </td></tr>
<tr class="memdesc:a95912a09cf7bd29259ef8d4473720424 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty.  <a href="#a95912a09cf7bd29259ef8d4473720424">More...</a><br /></td></tr>
<tr class="separator:a95912a09cf7bd29259ef8d4473720424 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c26db7d7178a3e3c0b4603c7d0fcd inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1c3c26db7d7178a3e3c0b4603c7d0fcd">front</a> ()</td></tr>
<tr class="memdesc:a1c3c26db7d7178a3e3c0b4603c7d0fcd inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the first element in this array, which must not be empty.  <a href="#a1c3c26db7d7178a3e3c0b4603c7d0fcd">More...</a><br /></td></tr>
<tr class="separator:a1c3c26db7d7178a3e3c0b4603c7d0fcd inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0460ec7ea1179ddf927e473d5bae34e1 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a0460ec7ea1179ddf927e473d5bae34e1">back</a> () const </td></tr>
<tr class="memdesc:a0460ec7ea1179ddf927e473d5bae34e1 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty.  <a href="#a0460ec7ea1179ddf927e473d5bae34e1">More...</a><br /></td></tr>
<tr class="separator:a0460ec7ea1179ddf927e473d5bae34e1 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf707303e5e68fb5147fa36862c2bc57 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#abf707303e5e68fb5147fa36862c2bc57">back</a> ()</td></tr>
<tr class="memdesc:abf707303e5e68fb5147fa36862c2bc57 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the last element in this array, which must not be empty.  <a href="#abf707303e5e68fb5147fa36862c2bc57">More...</a><br /></td></tr>
<tr class="separator:abf707303e5e68fb5147fa36862c2bc57 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89285bb25b06bc6a1b53fca6e63e3b7 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab89285bb25b06bc6a1b53fca6e63e3b7">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:ab89285bb25b06bc6a1b53fca6e63e3b7 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> that refers only to those element (without copying).  <a href="#ab89285bb25b06bc6a1b53fca6e63e3b7">More...</a><br /></td></tr>
<tr class="separator:ab89285bb25b06bc6a1b53fca6e63e3b7 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b3799cc9d10a4e4a6781292f7bdc15 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a33b3799cc9d10a4e4a6781292f7bdc15">updSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:a33b3799cc9d10a4e4a6781292f7bdc15 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as non-const operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="#a33b3799cc9d10a4e4a6781292f7bdc15">More...</a><br /></td></tr>
<tr class="separator:a33b3799cc9d10a4e4a6781292f7bdc15 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab22f2833fec6ab0cf54c865e4b982b5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aab22f2833fec6ab0cf54c865e4b982b5">cbegin</a> () const </td></tr>
<tr class="memdesc:aab22f2833fec6ab0cf54c865e4b982b5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>, which may be null (0) in that case but does not have to be.  <a href="#aab22f2833fec6ab0cf54c865e4b982b5">More...</a><br /></td></tr>
<tr class="separator:aab22f2833fec6ab0cf54c865e4b982b5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4365a113f327e918eaeb4e82aefdb0e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e">begin</a> () const </td></tr>
<tr class="memdesc:ad4365a113f327e918eaeb4e82aefdb0e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#aab22f2833fec6ab0cf54c865e4b982b5" title="Return a const pointer to the first element of this array if any, otherwise end(), which may be null (0) in that case but does not have to be. ">cbegin()</a>.  <a href="#ad4365a113f327e918eaeb4e82aefdb0e">More...</a><br /></td></tr>
<tr class="separator:ad4365a113f327e918eaeb4e82aefdb0e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa468711f19b67b25232650df6eeea608 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608">begin</a> ()</td></tr>
<tr class="memdesc:aa468711f19b67b25232650df6eeea608 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>.  <a href="#aa468711f19b67b25232650df6eeea608">More...</a><br /></td></tr>
<tr class="separator:aa468711f19b67b25232650df6eeea608 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add24067da9c7c229cdbd78f368191936 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#add24067da9c7c229cdbd78f368191936">cend</a> () const </td></tr>
<tr class="memdesc:add24067da9c7c229cdbd78f368191936 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="#add24067da9c7c229cdbd78f368191936">More...</a><br /></td></tr>
<tr class="separator:add24067da9c7c229cdbd78f368191936 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c075d504a14643b27c226d20d5807d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab7c075d504a14643b27c226d20d5807d">end</a> () const </td></tr>
<tr class="memdesc:ab7c075d504a14643b27c226d20d5807d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#add24067da9c7c229cdbd78f368191936" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="#ab7c075d504a14643b27c226d20d5807d">More...</a><br /></td></tr>
<tr class="separator:ab7c075d504a14643b27c226d20d5807d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5b2a07f725b6e943d45ad786bf02cb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb">end</a> ()</td></tr>
<tr class="memdesc:ace5b2a07f725b6e943d45ad786bf02cb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to what would be the element just after the last one in this array.  <a href="#ace5b2a07f725b6e943d45ad786bf02cb">More...</a><br /></td></tr>
<tr class="separator:ace5b2a07f725b6e943d45ad786bf02cb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e0272a509be58aa47bd4a661924ca inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a444e0272a509be58aa47bd4a661924ca">crbegin</a> () const </td></tr>
<tr class="memdesc:a444e0272a509be58aa47bd4a661924ca inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#aba2e82bd573b9e0fe365f76e929f92c0" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="#a444e0272a509be58aa47bd4a661924ca">More...</a><br /></td></tr>
<tr class="separator:a444e0272a509be58aa47bd4a661924ca inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d11403e60b499d439790bde90ffaeb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa4d11403e60b499d439790bde90ffaeb">rbegin</a> () const </td></tr>
<tr class="memdesc:aa4d11403e60b499d439790bde90ffaeb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a444e0272a509be58aa47bd4a661924ca" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="#aa4d11403e60b499d439790bde90ffaeb">More...</a><br /></td></tr>
<tr class="separator:aa4d11403e60b499d439790bde90ffaeb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add040a16da503b139f280a9e1a41c61d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d">rbegin</a> ()</td></tr>
<tr class="memdesc:add040a16da503b139f280a9e1a41c61d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> if the array is empty.  <a href="#add040a16da503b139f280a9e1a41c61d">More...</a><br /></td></tr>
<tr class="separator:add040a16da503b139f280a9e1a41c61d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2e82bd573b9e0fe365f76e929f92c0 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aba2e82bd573b9e0fe365f76e929f92c0">crend</a> () const </td></tr>
<tr class="memdesc:aba2e82bd573b9e0fe365f76e929f92c0 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#aba2e82bd573b9e0fe365f76e929f92c0">More...</a><br /></td></tr>
<tr class="separator:aba2e82bd573b9e0fe365f76e929f92c0 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6852373084f7377944ead91c6f1ab4 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aee6852373084f7377944ead91c6f1ab4">rend</a> () const </td></tr>
<tr class="memdesc:aee6852373084f7377944ead91c6f1ab4 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#aba2e82bd573b9e0fe365f76e929f92c0" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="#aee6852373084f7377944ead91c6f1ab4">More...</a><br /></td></tr>
<tr class="separator:aee6852373084f7377944ead91c6f1ab4 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fe28b711d20b58b18f5ad1bce34145 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145">rend</a> ()</td></tr>
<tr class="memdesc:a70fe28b711d20b58b18f5ad1bce34145 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#a70fe28b711d20b58b18f5ad1bce34145">More...</a><br /></td></tr>
<tr class="separator:a70fe28b711d20b58b18f5ad1bce34145 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0ee8a10102bcd47f53fe0e6c28d64c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1e0ee8a10102bcd47f53fe0e6c28d64c">cdata</a> () const </td></tr>
<tr class="memdesc:a1e0ee8a10102bcd47f53fe0e6c28d64c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="#a1e0ee8a10102bcd47f53fe0e6c28d64c">More...</a><br /></td></tr>
<tr class="separator:a1e0ee8a10102bcd47f53fe0e6c28d64c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6a58e82529049f52e953a347aeb30e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a7a6a58e82529049f52e953a347aeb30e">data</a> () const </td></tr>
<tr class="memdesc:a7a6a58e82529049f52e953a347aeb30e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayView__.html#a1e0ee8a10102bcd47f53fe0e6c28d64c" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="#a7a6a58e82529049f52e953a347aeb30e">More...</a><br /></td></tr>
<tr class="separator:a7a6a58e82529049f52e953a347aeb30e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318481efdb8fd67f17e28e67cc8cce24 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24">data</a> ()</td></tr>
<tr class="memdesc:a318481efdb8fd67f17e28e67cc8cce24 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first allocated element of the array, or a null pointer if no space is associated with the array.  <a href="#a318481efdb8fd67f17e28e67cc8cce24">More...</a><br /></td></tr>
<tr class="separator:a318481efdb8fd67f17e28e67cc8cce24 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93f8c651dab26b475900d4b768ae926 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size</a> () const </td></tr>
<tr class="separator:af93f8c651dab26b475900d4b768ae926 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35a88ad9923d73872f79308600821f1 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa35a88ad9923d73872f79308600821f1">max_size</a> () const </td></tr>
<tr class="separator:aa35a88ad9923d73872f79308600821f1 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75af4aca965b5170efc9b38956cac7c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab75af4aca965b5170efc9b38956cac7c">empty</a> () const </td></tr>
<tr class="separator:ab75af4aca965b5170efc9b38956cac7c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51052b7d71f1ba291a6a1dcfbafa6e80 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a51052b7d71f1ba291a6a1dcfbafa6e80">capacity</a> () const </td></tr>
<tr class="separator:a51052b7d71f1ba291a6a1dcfbafa6e80 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa573c73360997d8e1beb0a22f6b8452f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa573c73360997d8e1beb0a22f6b8452f">allocated</a> () const </td></tr>
<tr class="separator:aa573c73360997d8e1beb0a22f6b8452f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa22264fa554e99c1266d9404404e32 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a9aa22264fa554e99c1266d9404404e32">isOwner</a> () const </td></tr>
<tr class="separator:a9aa22264fa554e99c1266d9404404e32 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1ArrayViewConst__"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1ArrayViewConst__')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59">ArrayViewConst_</a> ()</td></tr>
<tr class="memdesc:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="#a6008f8ca816619f1b4a67c94027a2d59">More...</a><br /></td></tr>
<tr class="separator:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5412fa0b837f5e090f343180b2dbcdc8">ArrayViewConst_</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> &amp;src)</td></tr>
<tr class="memdesc:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow; the constructed const array object will be referencing the original source data.  <a href="#a5412fa0b837f5e090f343180b2dbcdc8">More...</a><br /></td></tr>
<tr class="separator:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aba351ab4073da6f9d4c13855b039df6b">ArrayViewConst_</a> (const T *first, const T *last1)</td></tr>
<tr class="memdesc:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an ArrayViewConst_&lt;T&gt; by referencing (sharing) a given range of const data [first,last1), without copying that data.  <a href="#aba351ab4073da6f9d4c13855b039df6b">More...</a><br /></td></tr>
<tr class="separator:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#acbb823ad8bafa05dae5c1a06b426c4a8">ArrayViewConst_</a> (const std::vector&lt; T, A &gt; &amp;src)</td></tr>
<tr class="memdesc:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a ArrayViewConst_&lt;T&gt; by referencing (sharing) the data in a const std::vector&lt;T&gt;, without copying the data; this is also an implicit conversion.  <a href="#acbb823ad8bafa05dae5c1a06b426c4a8">More...</a><br /></td></tr>
<tr class="separator:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cef62772e0c408bd3e0529417b8948 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a00cef62772e0c408bd3e0529417b8948">operator const ArrayView_&lt; T, X &gt; &amp;</a> () const </td></tr>
<tr class="memdesc:a00cef62772e0c408bd3e0529417b8948 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const ArrayView_&lt;T,X&gt;&amp;, which is harmless since the const result won't permit writing on the elements.  <a href="#a00cef62772e0c408bd3e0529417b8948">More...</a><br /></td></tr>
<tr class="separator:a00cef62772e0c408bd3e0529417b8948 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306a0b84ff4f9dd8981c5a978e2750f5 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a306a0b84ff4f9dd8981c5a978e2750f5">operator const Array_&lt; T, X &gt; &amp;</a> () const </td></tr>
<tr class="memdesc:a306a0b84ff4f9dd8981c5a978e2750f5 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const Array_&lt;T,X&gt;&amp;, which is harmless since the const result can't be used to write on or resize the data.  <a href="#a306a0b84ff4f9dd8981c5a978e2750f5">More...</a><br /></td></tr>
<tr class="separator:a306a0b84ff4f9dd8981c5a978e2750f5 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643">disconnect</a> ()</td></tr>
<tr class="memdesc:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect this array handle from any data to which it refers, restoring it to the condition it would be in if it had just been default-constructed.  <a href="#ace600fbc0738888ceef29cc7c0846643">More...</a><br /></td></tr>
<tr class="separator:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5f34fb008e433a59e3957ab27b811839">~ArrayViewConst_</a> ()</td></tr>
<tr class="memdesc:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a> for more information.  <a href="#a5f34fb008e433a59e3957ab27b811839">More...</a><br /></td></tr>
<tr class="separator:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4571082d90592c7b0f6761140e11edb3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3">size</a> () const </td></tr>
<tr class="memdesc:a4571082d90592c7b0f6761140e11edb3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current number of elements stored in this array.  <a href="#a4571082d90592c7b0f6761140e11edb3">More...</a><br /></td></tr>
<tr class="separator:a4571082d90592c7b0f6761140e11edb3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dff9e3f09bd7f0ca14dec2861a626ea inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea">max_size</a> () const </td></tr>
<tr class="memdesc:a4dff9e3f09bd7f0ca14dec2861a626ea inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowable size for this array.  <a href="#a4dff9e3f09bd7f0ca14dec2861a626ea">More...</a><br /></td></tr>
<tr class="separator:a4dff9e3f09bd7f0ca14dec2861a626ea inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45ba916abcb168e7337b80890c8d68c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ad45ba916abcb168e7337b80890c8d68c">empty</a> () const </td></tr>
<tr class="memdesc:ad45ba916abcb168e7337b80890c8d68c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no elements currently stored in this array.  <a href="#ad45ba916abcb168e7337b80890c8d68c">More...</a><br /></td></tr>
<tr class="separator:ad45ba916abcb168e7337b80890c8d68c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df09ea748ac2750e730981e7563526f inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f">capacity</a> () const </td></tr>
<tr class="memdesc:a3df09ea748ac2750e730981e7563526f inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements this array can currently hold without requiring reallocation.  <a href="#a3df09ea748ac2750e730981e7563526f">More...</a><br /></td></tr>
<tr class="separator:a3df09ea748ac2750e730981e7563526f inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1c27ea8ca7b9f3411d438693fd8a2a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3c1c27ea8ca7b9f3411d438693fd8a2a">allocated</a> () const </td></tr>
<tr class="memdesc:a3c1c27ea8ca7b9f3411d438693fd8a2a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amount of heap space owned by this array; this is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> for owner arrays but is zero for non-owners.  <a href="#a3c1c27ea8ca7b9f3411d438693fd8a2a">More...</a><br /></td></tr>
<tr class="separator:a3c1c27ea8ca7b9f3411d438693fd8a2a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c40081730e9681d6102972f42904f1 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a30c40081730e9681d6102972f42904f1">isOwner</a> () const </td></tr>
<tr class="memdesc:a30c40081730e9681d6102972f42904f1 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this array own the data to which it refers? If not, it can't be resized, and the destructor will not free any heap space nor call any element destructors.  <a href="#a30c40081730e9681d6102972f42904f1">More...</a><br /></td></tr>
<tr class="separator:a30c40081730e9681d6102972f42904f1 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa06a13341105ac7773a9c6bcd6a851c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#afa06a13341105ac7773a9c6bcd6a851c">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:afa06a13341105ac7773a9c6bcd6a851c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="#afa06a13341105ac7773a9c6bcd6a851c">More...</a><br /></td></tr>
<tr class="separator:afa06a13341105ac7773a9c6bcd6a851c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5d31ec735550ba4b262b8e5f387020 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b5d31ec735550ba4b262b8e5f387020">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a4b5d31ec735550ba4b262b8e5f387020 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#a4b5d31ec735550ba4b262b8e5f387020">More...</a><br /></td></tr>
<tr class="separator:a4b5d31ec735550ba4b262b8e5f387020 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af8a30f98edabfef434169ac33831e2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2af8a30f98edabfef434169ac33831e2">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a2af8a30f98edabfef434169ac33831e2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#a2af8a30f98edabfef434169ac33831e2">More...</a><br /></td></tr>
<tr class="separator:a2af8a30f98edabfef434169ac33831e2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d5eed816397cc84bc47af96645e554 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a14d5eed816397cc84bc47af96645e554">front</a> () const </td></tr>
<tr class="memdesc:a14d5eed816397cc84bc47af96645e554 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty (we'll check in a Debug build but not Release).  <a href="#a14d5eed816397cc84bc47af96645e554">More...</a><br /></td></tr>
<tr class="separator:a14d5eed816397cc84bc47af96645e554 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26683b980dcd87bafd5c6446d8f8b25b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a26683b980dcd87bafd5c6446d8f8b25b">back</a> () const </td></tr>
<tr class="memdesc:a26683b980dcd87bafd5c6446d8f8b25b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty (we'll check in a Debug build but not Release).  <a href="#a26683b980dcd87bafd5c6446d8f8b25b">More...</a><br /></td></tr>
<tr class="separator:a26683b980dcd87bafd5c6446d8f8b25b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1816a17c6b643eb0967f954cdd96635 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab1816a17c6b643eb0967f954cdd96635">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const </td></tr>
<tr class="memdesc:ab1816a17c6b643eb0967f954cdd96635 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> that refers only to those element (without copying).  <a href="#ab1816a17c6b643eb0967f954cdd96635">More...</a><br /></td></tr>
<tr class="separator:ab1816a17c6b643eb0967f954cdd96635 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288833be443e0f02d958f5cfe74312ba inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a288833be443e0f02d958f5cfe74312ba">getSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const </td></tr>
<tr class="memdesc:a288833be443e0f02d958f5cfe74312ba inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const form of operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="#a288833be443e0f02d958f5cfe74312ba">More...</a><br /></td></tr>
<tr class="separator:a288833be443e0f02d958f5cfe74312ba inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e34902f0533ffbda435880fd8ce34b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b">cbegin</a> () const </td></tr>
<tr class="memdesc:ac3e34902f0533ffbda435880fd8ce34b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>, which may be null (0) in that case but does not have to be.  <a href="#ac3e34902f0533ffbda435880fd8ce34b">More...</a><br /></td></tr>
<tr class="separator:ac3e34902f0533ffbda435880fd8ce34b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0664dc29fe9f3d2d3f38433774d9c3a4 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4">cend</a> () const </td></tr>
<tr class="memdesc:a0664dc29fe9f3d2d3f38433774d9c3a4 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="#a0664dc29fe9f3d2d3f38433774d9c3a4">More...</a><br /></td></tr>
<tr class="separator:a0664dc29fe9f3d2d3f38433774d9c3a4 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8cb9dedb2d0710570621910a016108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108">begin</a> () const </td></tr>
<tr class="memdesc:a0f8cb9dedb2d0710570621910a016108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a>.  <a href="#a0f8cb9dedb2d0710570621910a016108">More...</a><br /></td></tr>
<tr class="separator:a0f8cb9dedb2d0710570621910a016108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6349807c889c1155e01d429e264b08e8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8">end</a> () const </td></tr>
<tr class="memdesc:a6349807c889c1155e01d429e264b08e8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend(). ">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="#a6349807c889c1155e01d429e264b08e8">More...</a><br /></td></tr>
<tr class="separator:a6349807c889c1155e01d429e264b08e8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca9a931016a896c03b783f7a5bb2824 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824">crbegin</a> () const </td></tr>
<tr class="memdesc:aaca9a931016a896c03b783f7a5bb2824 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="#aaca9a931016a896c03b783f7a5bb2824">More...</a><br /></td></tr>
<tr class="separator:aaca9a931016a896c03b783f7a5bb2824 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4736f16ae05ebee9e34077072496436b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b">crend</a> () const </td></tr>
<tr class="memdesc:a4736f16ae05ebee9e34077072496436b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#a4736f16ae05ebee9e34077072496436b">More...</a><br /></td></tr>
<tr class="separator:a4736f16ae05ebee9e34077072496436b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de43406f71aed2fc534da92c4005256 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4de43406f71aed2fc534da92c4005256">rbegin</a> () const </td></tr>
<tr class="memdesc:a4de43406f71aed2fc534da92c4005256 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4de43406f71aed2fc534da92c4005256" title="The const version of rbegin() is the same as crbegin(). ">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="#a4de43406f71aed2fc534da92c4005256">More...</a><br /></td></tr>
<tr class="separator:a4de43406f71aed2fc534da92c4005256 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0d66ba65094d8b6cf75922d846ff3c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6e0d66ba65094d8b6cf75922d846ff3c">rend</a> () const </td></tr>
<tr class="memdesc:a6e0d66ba65094d8b6cf75922d846ff3c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6e0d66ba65094d8b6cf75922d846ff3c" title="The const version of rend() is the same as crend(). ">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="#a6e0d66ba65094d8b6cf75922d846ff3c">More...</a><br /></td></tr>
<tr class="separator:a6e0d66ba65094d8b6cf75922d846ff3c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2cf338eaf2590b4085bfb110470388 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388">cdata</a> () const </td></tr>
<tr class="memdesc:a4b2cf338eaf2590b4085bfb110470388 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="#a4b2cf338eaf2590b4085bfb110470388">More...</a><br /></td></tr>
<tr class="separator:a4b2cf338eaf2590b4085bfb110470388 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f2581b552a2df91b8f2b7f9abae43d inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d">data</a> () const </td></tr>
<tr class="memdesc:aa9f2581b552a2df91b8f2b7f9abae43d inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d" title="The const version of the data() method is identical to cdata(). ">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="#aa9f2581b552a2df91b8f2b7f9abae43d">More...</a><br /></td></tr>
<tr class="separator:aa9f2581b552a2df91b8f2b7f9abae43d inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8a1771c28a26738d4e217ec67586f9c8"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a8a1771c28a26738d4e217ec67586f9c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8a1771c28a26738d4e217ec67586f9c8">swap</a> (<a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt; &amp;a1, <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt; &amp;a2)</td></tr>
<tr class="memdesc:a8a1771c28a26738d4e217ec67586f9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a specialization of the STL std::swap() algorithm which uses the constant time built-in <a class="el" href="classSimTK_1_1Array__.html#a4c544ef3a4eee81c7580699e793e0f92" title="This is a specialized algorithm providing constant time exchange of data with another array that has ...">swap()</a> member of the <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> class.  <a href="#a8a1771c28a26738d4e217ec67586f9c8">More...</a><br /></td></tr>
<tr class="separator:a8a1771c28a26738d4e217ec67586f9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Array_&lt;T&gt; serialization and I/O</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are at namespace scope but are logically part of the Array classes.</p>
<p>These deal with reading and writing Arrays from and to streams, which places an additional requirement on the element type T: the element must support the same operation you are trying to do on the Array as a whole. </p>
</div></td></tr>
<tr class="memitem:a015cef5d8e534e632955fcca6ea444f8"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a015cef5d8e534e632955fcca6ea444f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a015cef5d8e534e632955fcca6ea444f8">writeUnformatted</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a015cef5d8e534e632955fcca6ea444f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize <a class="el" href="classSimTK_1_1Array__.html#a015cef5d8e534e632955fcca6ea444f8" title="Specialize writeUnformatted() for Array_&lt;E,X&gt; to delegate to element type E, with spaces separating t...">writeUnformatted()</a> for Array_&lt;E,X&gt; to delegate to element type E, with spaces separating the elements.  <a href="#a015cef5d8e534e632955fcca6ea444f8">More...</a><br /></td></tr>
<tr class="separator:a015cef5d8e534e632955fcca6ea444f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abedbcfc5b21bd9fa859208247aec72"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a6abedbcfc5b21bd9fa859208247aec72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a6abedbcfc5b21bd9fa859208247aec72">writeFormatted</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a6abedbcfc5b21bd9fa859208247aec72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize <a class="el" href="classSimTK_1_1Array__.html#a6abedbcfc5b21bd9fa859208247aec72" title="Specialize writeFormatted() for Array_&lt;E,X&gt; to delegate to element type E, with surrounding parenthes...">writeFormatted()</a> for Array_&lt;E,X&gt; to delegate to element type E, with surrounding parentheses and commas separating the elements.  <a href="#a6abedbcfc5b21bd9fa859208247aec72">More...</a><br /></td></tr>
<tr class="separator:a6abedbcfc5b21bd9fa859208247aec72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8575e59ff1ed3dcb8e52d7dd44ebb426"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a8575e59ff1ed3dcb8e52d7dd44ebb426"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8575e59ff1ed3dcb8e52d7dd44ebb426">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt; &amp;a)</td></tr>
<tr class="memdesc:a8575e59ff1ed3dcb8e52d7dd44ebb426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a human readable representation of an array to an std::ostream (like std::cout).  <a href="#a8575e59ff1ed3dcb8e52d7dd44ebb426">More...</a><br /></td></tr>
<tr class="separator:a8575e59ff1ed3dcb8e52d7dd44ebb426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b300ce2032c6315983114f0b7e84e92"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a6b300ce2032c6315983114f0b7e84e92"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a6b300ce2032c6315983114f0b7e84e92">readUnformatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a6b300ce2032c6315983114f0b7e84e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1Array__.html#a6b300ce2032c6315983114f0b7e84e92" title="Specialization of readUnformatted() for variable-length Array_&lt;T,X&gt;; continues reading whitespace-sep...">readUnformatted()</a> for variable-length Array_&lt;T,X&gt;; continues reading whitespace-separated tokens until error or eof.  <a href="#a6b300ce2032c6315983114f0b7e84e92">More...</a><br /></td></tr>
<tr class="separator:a6b300ce2032c6315983114f0b7e84e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a8a24c48ad3dff0c852095f0347941"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a65a8a24c48ad3dff0c852095f0347941"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a65a8a24c48ad3dff0c852095f0347941">readFormatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a65a8a24c48ad3dff0c852095f0347941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1Array__.html#a65a8a24c48ad3dff0c852095f0347941" title="Specialization of readFormatted() for variable-length Array_&lt;T,X&gt;; uses readArrayFromStream() to cons...">readFormatted()</a> for variable-length Array_&lt;T,X&gt;; uses <a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15" title="Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values option...">readArrayFromStream()</a> to consume an appropriately-formatted array until error, closing parenthesis or bracket, or eof.  <a href="#a65a8a24c48ad3dff0c852095f0347941">More...</a><br /></td></tr>
<tr class="separator:a65a8a24c48ad3dff0c852095f0347941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a452cab4756ae07c3ab22c155eb1b15"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a0a452cab4756ae07c3ab22c155eb1b15"><td class="memTemplItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15">readArrayFromStream</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:a0a452cab4756ae07c3ab22c155eb1b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values optionally surrounded by parentheses (), square brackets [], or curly braces {}.  <a href="#a0a452cab4756ae07c3ab22c155eb1b15">More...</a><br /></td></tr>
<tr class="separator:a0a452cab4756ae07c3ab22c155eb1b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34546fb36b84171e76276a508121a3ce"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a34546fb36b84171e76276a508121a3ce"><td class="memTemplItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce">fillArrayFromStream</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:a34546fb36b84171e76276a508121a3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a fixed number of elements from a stream into an Array.  <a href="#a34546fb36b84171e76276a508121a3ce">More...</a><br /></td></tr>
<tr class="separator:a34546fb36b84171e76276a508121a3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd40fd273bd41041bb7138a3268ca82"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:adbd40fd273bd41041bb7138a3268ca82"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:adbd40fd273bd41041bb7138a3268ca82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T, optionally delimited by parentheses, brackets, or braces.  <a href="#adbd40fd273bd41041bb7138a3268ca82">More...</a><br /></td></tr>
<tr class="separator:adbd40fd273bd41041bb7138a3268ca82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These operators permit lexicographical comparisons between two comparable <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> objects, possibly with differing element and index types, and between an <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> object and a comparable std::vector object.</p>
</div></td></tr>
<tr class="memitem:a1e25d47eeb9e34faa78ee38812b194d8"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a1e25d47eeb9e34faa78ee38812b194d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1e25d47eeb9e34faa78ee38812b194d8">operator==</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a1e25d47eeb9e34faa78ee38812b194d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> objects are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T1==T2.  <a href="#a1e25d47eeb9e34faa78ee38812b194d8">More...</a><br /></td></tr>
<tr class="separator:a1e25d47eeb9e34faa78ee38812b194d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79b082dbed61adf809400e05027c595"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:aa79b082dbed61adf809400e05027c595"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa79b082dbed61adf809400e05027c595">operator!=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:aa79b082dbed61adf809400e05027c595"><td class="mdescLeft">&#160;</td><td class="mdescRight">The not equal operator is implemented using the equal operator.  <a href="#aa79b082dbed61adf809400e05027c595">More...</a><br /></td></tr>
<tr class="separator:aa79b082dbed61adf809400e05027c595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1218fae627e26b17ed948a62e87cc8"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a0e1218fae627e26b17ed948a62e87cc8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a0e1218fae627e26b17ed948a62e87cc8">operator&lt;</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a0e1218fae627e26b17ed948a62e87cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> objects are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter array (in which case the shorter one is "less than" the longer).  <a href="#a0e1218fae627e26b17ed948a62e87cc8">More...</a><br /></td></tr>
<tr class="separator:a0e1218fae627e26b17ed948a62e87cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80423b9a73fd93e07d8465c97e999af"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:ad80423b9a73fd93e07d8465c97e999af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad80423b9a73fd93e07d8465c97e999af">operator&gt;=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:ad80423b9a73fd93e07d8465c97e999af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than or equal operator is implemented using the less than operator.  <a href="#ad80423b9a73fd93e07d8465c97e999af">More...</a><br /></td></tr>
<tr class="separator:ad80423b9a73fd93e07d8465c97e999af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93cc22c503f9f75f1be2cbbb2c97714"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:ac93cc22c503f9f75f1be2cbbb2c97714"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ac93cc22c503f9f75f1be2cbbb2c97714">operator&gt;</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:ac93cc22c503f9f75f1be2cbbb2c97714"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1.  <a href="#ac93cc22c503f9f75f1be2cbbb2c97714">More...</a><br /></td></tr>
<tr class="separator:ac93cc22c503f9f75f1be2cbbb2c97714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8822b4815845e58a47af6b5720791698"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a8822b4815845e58a47af6b5720791698"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8822b4815845e58a47af6b5720791698">operator&lt;=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a8822b4815845e58a47af6b5720791698"><td class="mdescLeft">&#160;</td><td class="mdescRight">The less than or equal operator is implemented using the greater than operator.  <a href="#a8822b4815845e58a47af6b5720791698">More...</a><br /></td></tr>
<tr class="separator:a8822b4815845e58a47af6b5720791698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39975ed123e3738da698ea6d0ddc7a4a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:a39975ed123e3738da698ea6d0ddc7a4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a39975ed123e3738da698ea6d0ddc7a4a">operator==</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a39975ed123e3738da698ea6d0ddc7a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Array_&lt;T1&gt; and an std::vector&lt;T2&gt; are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T1==T2.  <a href="#a39975ed123e3738da698ea6d0ddc7a4a">More...</a><br /></td></tr>
<tr class="separator:a39975ed123e3738da698ea6d0ddc7a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bef2d3446751e985a922ecb0681653c"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a5bef2d3446751e985a922ecb0681653c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a5bef2d3446751e985a922ecb0681653c">operator==</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a5bef2d3446751e985a922ecb0681653c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An std::vector&lt;T1&gt; and an Array_&lt;T2&gt; are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T2==T1.  <a href="#a5bef2d3446751e985a922ecb0681653c">More...</a><br /></td></tr>
<tr class="separator:a5bef2d3446751e985a922ecb0681653c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688f8af308de34d0431205f7d854aee3"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:a688f8af308de34d0431205f7d854aee3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a688f8af308de34d0431205f7d854aee3">operator!=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a688f8af308de34d0431205f7d854aee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The not equal operator is implemented using the equal operator.  <a href="#a688f8af308de34d0431205f7d854aee3">More...</a><br /></td></tr>
<tr class="separator:a688f8af308de34d0431205f7d854aee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d04f55c1a275128219e677a974254c9"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a7d04f55c1a275128219e677a974254c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7d04f55c1a275128219e677a974254c9">operator!=</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a7d04f55c1a275128219e677a974254c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The not equal operator is implemented using the equal operator.  <a href="#a7d04f55c1a275128219e677a974254c9">More...</a><br /></td></tr>
<tr class="separator:a7d04f55c1a275128219e677a974254c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbec0e1348a20404c060b9c5523544f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:addbec0e1348a20404c060b9c5523544f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#addbec0e1348a20404c060b9c5523544f">operator&lt;</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:addbec0e1348a20404c060b9c5523544f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Array_&lt;T1&gt; and std::vector&lt;T2&gt; are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter container (in which case the shorter one is "less than" the longer).  <a href="#addbec0e1348a20404c060b9c5523544f">More...</a><br /></td></tr>
<tr class="separator:addbec0e1348a20404c060b9c5523544f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa929813dea46bf41f7ffee7053566f86"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:aa929813dea46bf41f7ffee7053566f86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa929813dea46bf41f7ffee7053566f86">operator&lt;</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:aa929813dea46bf41f7ffee7053566f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">An std::vector&lt;T1&gt; and Array_&lt;T2&gt; are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter container (in which case the shorter one is "less than" the longer).  <a href="#aa929813dea46bf41f7ffee7053566f86">More...</a><br /></td></tr>
<tr class="separator:aa929813dea46bf41f7ffee7053566f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e151401cab82f28a4d2f6c43bdaeb0"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:a81e151401cab82f28a4d2f6c43bdaeb0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a81e151401cab82f28a4d2f6c43bdaeb0">operator&gt;=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a81e151401cab82f28a4d2f6c43bdaeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than or equal operator is implemented using the less than operator.  <a href="#a81e151401cab82f28a4d2f6c43bdaeb0">More...</a><br /></td></tr>
<tr class="separator:a81e151401cab82f28a4d2f6c43bdaeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9fc6fb86e0e02b422ea858ba216f94"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a1c9fc6fb86e0e02b422ea858ba216f94"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1c9fc6fb86e0e02b422ea858ba216f94">operator&gt;=</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a1c9fc6fb86e0e02b422ea858ba216f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than or equal operator is implemented using the less than operator.  <a href="#a1c9fc6fb86e0e02b422ea858ba216f94">More...</a><br /></td></tr>
<tr class="separator:a1c9fc6fb86e0e02b422ea858ba216f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad057e98ddbd0b80ab053519caa9dd2ea"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:ad057e98ddbd0b80ab053519caa9dd2ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad057e98ddbd0b80ab053519caa9dd2ea">operator&gt;</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:ad057e98ddbd0b80ab053519caa9dd2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1.  <a href="#ad057e98ddbd0b80ab053519caa9dd2ea">More...</a><br /></td></tr>
<tr class="separator:ad057e98ddbd0b80ab053519caa9dd2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d14e73a05783839ed5c679278764d4"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:ad7d14e73a05783839ed5c679278764d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad7d14e73a05783839ed5c679278764d4">operator&gt;</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:ad7d14e73a05783839ed5c679278764d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1.  <a href="#ad7d14e73a05783839ed5c679278764d4">More...</a><br /></td></tr>
<tr class="separator:ad7d14e73a05783839ed5c679278764d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6219dc0d49e5f4d40d4a5d7954c5adb"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:ad6219dc0d49e5f4d40d4a5d7954c5adb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad6219dc0d49e5f4d40d4a5d7954c5adb">operator&lt;=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:ad6219dc0d49e5f4d40d4a5d7954c5adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The less than or equal operator is implemented using the greater than operator.  <a href="#ad6219dc0d49e5f4d40d4a5d7954c5adb">More...</a><br /></td></tr>
<tr class="separator:ad6219dc0d49e5f4d40d4a5d7954c5adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463986b88adfd8319e9a2ddcb7b21d0e"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a463986b88adfd8319e9a2ddcb7b21d0e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a463986b88adfd8319e9a2ddcb7b21d0e">operator&lt;=</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a463986b88adfd8319e9a2ddcb7b21d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The less than or equal operator is implemented using the greater than operator.  <a href="#a463986b88adfd8319e9a2ddcb7b21d0e">More...</a><br /></td></tr>
<tr class="separator:a463986b88adfd8319e9a2ddcb7b21d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classSimTK_1_1ArrayView__"><td colspan="2" onclick="javascript:toggleInherit('related_classSimTK_1_1ArrayView__')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a2f916862f035a63e2406b6c47c57a2f3 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a2f916862f035a63e2406b6c47c57a2f3 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3">readUnformatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a2f916862f035a63e2406b6c47c57a2f3 inherit related_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3" title="Specialization of readUnformatted() for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated toke...">readUnformatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated tokens until the expected number have been read.  <a href="#a2f916862f035a63e2406b6c47c57a2f3">More...</a><br /></td></tr>
<tr class="separator:a2f916862f035a63e2406b6c47c57a2f3 inherit related_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87616be589a0d76e0461c1d7c869e91 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:aa87616be589a0d76e0461c1d7c869e91 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91">readFormatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:aa87616be589a0d76e0461c1d7c869e91 inherit related_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91" title="Specialization of readFormatted() for fixed-length ArrayView_&lt;T,X&gt;; uses fillArrayViewFromStream() to...">readFormatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; uses <a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03" title="Read in a fixed number of elements from a stream into an ArrayView. ">fillArrayViewFromStream()</a> to consume an appropriately-formatted fixed-size array.  <a href="#aa87616be589a0d76e0461c1d7c869e91">More...</a><br /></td></tr>
<tr class="separator:aa87616be589a0d76e0461c1d7c869e91 inherit related_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0c0d7769abbfe61b560361afe19f03 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a3c0c0d7769abbfe61b560361afe19f03 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03">fillArrayViewFromStream</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:a3c0c0d7769abbfe61b560361afe19f03 inherit related_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a fixed number of elements from a stream into an ArrayView.  <a href="#a3c0c0d7769abbfe61b560361afe19f03">More...</a><br /></td></tr>
<tr class="separator:a3c0c0d7769abbfe61b560361afe19f03 inherit related_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7c28435897527058bfecae5e2f407a inherit related_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:acc7c28435897527058bfecae5e2f407a inherit related_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acc7c28435897527058bfecae5e2f407a">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:acc7c28435897527058bfecae5e2f407a inherit related_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a (fixed size n) ArrayView_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T, optionally delimited by parentheses, square brackets, or curly braces.  <a href="#acc7c28435897527058bfecae5e2f407a">More...</a><br /></td></tr>
<tr class="separator:acc7c28435897527058bfecae5e2f407a inherit related_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Element insertion and removal</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp04278d7a280cc864bdefd140f72675a7"></a>These are methods that change the number of elements in the array by insertion or erasure.</p>
</td></tr>
<tr class="memitem:a13b95bc701e5bd09dad7ee38e069b669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a13b95bc701e5bd09dad7ee38e069b669">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a13b95bc701e5bd09dad7ee38e069b669"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method increases the size of the Array by one element at the end and initializes that element by copy constructing it from the given value.  <a href="#a13b95bc701e5bd09dad7ee38e069b669">More...</a><br /></td></tr>
<tr class="separator:a13b95bc701e5bd09dad7ee38e069b669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b698ae20b857ce3de014b8996f3b1e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5">push_back</a> ()</td></tr>
<tr class="memdesc:a7b698ae20b857ce3de014b8996f3b1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a non-standard version of <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back()</a> that increases the size of the array by one default-constructed element at the end.  <a href="#a7b698ae20b857ce3de014b8996f3b1e5">More...</a><br /></td></tr>
<tr class="separator:a7b698ae20b857ce3de014b8996f3b1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceb31ef48594914eaef9ddcec92791c"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7ceb31ef48594914eaef9ddcec92791c">raw_push_back</a> ()</td></tr>
<tr class="memdesc:a7ceb31ef48594914eaef9ddcec92791c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This dangerous method increases the Array's size by one element at the end but doesn't perform any construction so the memory is filled with garbage.  <a href="#a7ceb31ef48594914eaef9ddcec92791c">More...</a><br /></td></tr>
<tr class="separator:a7ceb31ef48594914eaef9ddcec92791c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b5b478c9ac203ed767eadf7828ffcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a54b5b478c9ac203ed767eadf7828ffcd">pop_back</a> ()</td></tr>
<tr class="memdesc:a54b5b478c9ac203ed767eadf7828ffcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element from this array, which must not be empty.  <a href="#a54b5b478c9ac203ed767eadf7828ffcd">More...</a><br /></td></tr>
<tr class="separator:a54b5b478c9ac203ed767eadf7828ffcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a656cb3128af0259d85978a61b7e01"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01">erase</a> (T *first, const T *last1)</td></tr>
<tr class="memdesc:a52a656cb3128af0259d85978a61b7e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in range [first,last1), packing in any later elements into the newly-available space and reducing the array's size by the number of elements erased.  <a href="#a52a656cb3128af0259d85978a61b7e01">More...</a><br /></td></tr>
<tr class="separator:a52a656cb3128af0259d85978a61b7e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818361e237b91adc12d2122f119c579c"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a818361e237b91adc12d2122f119c579c">erase</a> (T *p)</td></tr>
<tr class="memdesc:a818361e237b91adc12d2122f119c579c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase just one element, moving all subsequent elements down one slot and reducing the array's size by one.  <a href="#a818361e237b91adc12d2122f119c579c">More...</a><br /></td></tr>
<tr class="separator:a818361e237b91adc12d2122f119c579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3f2ff76ae0b004c5e21c3aa170ebf6"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aea3f2ff76ae0b004c5e21c3aa170ebf6">eraseFast</a> (T *p)</td></tr>
<tr class="memdesc:aea3f2ff76ae0b004c5e21c3aa170ebf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Be careful with this non-standard extension; it erases one element and then moves the last one in its place which changes the element order from what it was before (unlike the standard <a class="el" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase()</a> method).  <a href="#aea3f2ff76ae0b004c5e21c3aa170ebf6">More...</a><br /></td></tr>
<tr class="separator:aea3f2ff76ae0b004c5e21c3aa170ebf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95f49692c338895df4ddc36752b4baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af95f49692c338895df4ddc36752b4baa">clear</a> ()</td></tr>
<tr class="memdesc:af95f49692c338895df4ddc36752b4baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements currently in this array without changing the capacity; equivalent to erase(<a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a>,<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>) but a little faster.  <a href="#af95f49692c338895df4ddc36752b4baa">More...</a><br /></td></tr>
<tr class="separator:af95f49692c338895df4ddc36752b4baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6c04b85ed597b657f4cd244c02c52d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7c6c04b85ed597b657f4cd244c02c52d">insert</a> (T *p, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;value)</td></tr>
<tr class="memdesc:a7c6c04b85ed597b657f4cd244c02c52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>n</em> copies of a given value at a particular location within this array, moving all following elements up by <em>n</em> positions.  <a href="#a7c6c04b85ed597b657f4cd244c02c52d">More...</a><br /></td></tr>
<tr class="separator:a7c6c04b85ed597b657f4cd244c02c52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de9710bd314b227b6d7fb9b1e2e5013"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1de9710bd314b227b6d7fb9b1e2e5013">insert</a> (T *p, const T &amp;value)</td></tr>
<tr class="memdesc:a1de9710bd314b227b6d7fb9b1e2e5013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new element at a given location within this array, initializing it to a copy of a given value and moving all following elements up one position.  <a href="#a1de9710bd314b227b6d7fb9b1e2e5013">More...</a><br /></td></tr>
<tr class="separator:a1de9710bd314b227b6d7fb9b1e2e5013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e597a8ecd02706680bf8920c5a15f29"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a9e597a8ecd02706680bf8920c5a15f29"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a9e597a8ecd02706680bf8920c5a15f29">insert</a> (T *p, const T2 *first, const T2 *last1)</td></tr>
<tr class="memdesc:a9e597a8ecd02706680bf8920c5a15f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements in a range [first,last1) into this array at a given position <em>p</em>, moving all following elements up by n=(last1-first) positions.  <a href="#a9e597a8ecd02706680bf8920c5a15f29">More...</a><br /></td></tr>
<tr class="separator:a9e597a8ecd02706680bf8920c5a15f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2abd8e9d2146f344a88f96d1f839db0"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ae2abd8e9d2146f344a88f96d1f839db0"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ae2abd8e9d2146f344a88f96d1f839db0">insert</a> (T *p, const Iter &amp;first, const Iter &amp;last1)</td></tr>
<tr class="memdesc:ae2abd8e9d2146f344a88f96d1f839db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements in a range [first,last1) where the range is given by non-pointer iterators.  <a href="#ae2abd8e9d2146f344a88f96d1f839db0">More...</a><br /></td></tr>
<tr class="separator:ae2abd8e9d2146f344a88f96d1f839db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class X&gt;<br />
class SimTK::Array_&lt; T, X &gt;</h3>

<p>The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library (STL) std::vector&lt;T&gt; class, but with some important advantages in performance, and functionality, and binary compatibility. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object to be stored in this container. </td></tr>
    <tr><td class="paramname">X</td><td>The type to be used for indexing this container, with default unsigned (not size_t). Any integral type may be used, as well as user types that satisfy the requirements discussed with class <a class="el" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Performance:</dt><dd>There are several performance and memory footprint problems with the C++ standard STL design in general, and with Microsoft's implementation in particular, that are addressed here. Microsoft in its wisdom decided that STL containers should still do runtime range checks in Release builds for safety, but that makes them too slow for use in some high-performance contexts (and also breaks the promise of generic programming but that's another rant). In practice, VC++9 std::vector runs about half speed for simple operations like indexing and push_back. Attempting to disable these runtime checks with _SECURE_SCL breaks binary compatibility. In contrast the performance of this Array_&lt;T&gt; class on any platform is indistinguishable from what you would get by managing your own heap-allocated arrays.</dd></dl>
<dl class="section user"><dt></dt><dd>Regarding memory footprint, the typical implementation of std::vector uses three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines. Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit machine &ndash; I don't know what they do on a 64 bit machine but I'm not optimistic! <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> instead uses one pointer and two lengths for a total size as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.</dd></dl>
<dl class="section user"><dt></dt><dd>Some nuts and bolts:</dd></dl>
<ul>
<li>We promise that no heap allocation occurs when an empty Array_&lt;T&gt; object is declared (that is, when an Array_&lt;T&gt; is default-constructed); in that case both <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> and <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> are null.</li>
<li>Array_&lt;T&gt; methods are extremely fast in Release builds with zero overhead, inline, unchecked methods. The implementations of inline methods are kept small to ensure that they are actually inlined in practice; and generated assembly code was examined to make sure.</li>
<li>There are some dangerous extensions provided that permit the expert user to construct objects directly into the array without having to copy them, a big win for complicated objects and even bigger for those that don't have copy constructors!</li>
<li>There is a constant-time <a class="el" href="classSimTK_1_1Array__.html#aea3f2ff76ae0b004c5e21c3aa170ebf6" title="Be careful with this non-standard extension; it erases one element and then moves the last one in its...">eraseFast()</a> method you can use if you don't mind the array being reordered after the erase. This avoids the extremely expensive "compress" activity required by the standard <a class="el" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase()</a> method.</li>
<li>The optional index-type template parameter can be used to reduce the memory footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit pointer and two shorts).</li>
<li>The default size_type for an Array_&lt;T&gt; is a 32-bit unsigned integer rather than a size_t. On a 64-bit machine that keeps the overhead down substantially since the structure is then one 64-bit pointer and two 32-bit integers, fitting tightly into a cleanly alignable 16 bytes.</li>
</ul>
<dl class="section user"><dt>Functionality:</dt><dd>For the most part Array_&lt;T&gt; is a plug-compatible replacement for std::vector&lt;T&gt;, and everything that both classes can do is done with an identical API. However, there are a few additions and subtractions:</dd></dl>
<ul>
<li>This class always uses the default new/delete allocator; there is no option to specify your own as there is in std::vector.</li>
<li>Instead of an allocator, the second template argument X to Array_&lt;T,X&gt; is an optional index type which can be used to provide type-safe indexing (i.e. the array can only be indexed by indices of a particular type, like <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>). This has zero performance cost if the index is an integral type or class consisting of only an integral value such as those produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.</li>
<li>You can create uninitialized slots in the array and construct directly into them rather than having to construct a temporary object which must then be copied into the array.</li>
<li>You can create Array_&lt;T&gt; objects that reference existing data, including the contents of std::vectors.</li>
<li>Where possible this class implements the new std::vector features proposed for the C++0x standard (see below).</li>
</ul>
<dl class="section user"><dt>Compatibility:</dt><dd>Included here are binary compatibility issues and compatibility with the C++ standard STL objects.</dd></dl>
<ul>
<li>Most important, it is safe to pass an Array_&lt;T&gt; through an API to a binary library without worrying about compiler version or Release/Debug compatibility issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit vs. 32 bit), Array_&lt;T&gt; has an extremely stable memory layout that is preserved across compiler versions, and between Release and Debug builds. This allows us to use Array_&lt;T&gt; in the <a class="el" href="namespaceSimTK.html" title="This is the top-level SimTK namespace into which all SimTK names are placed to avoid collision with o...">SimTK</a> API where use of std::vector&lt;T&gt; would be desirable but problematic.</li>
<li>It supports all standard types, methods, iterators, and operators of the C++98 standard std::vector and the C++0x proposed improvements other than those requiring rvalue references, so it works smoothly with all STL containers and algorithms.</li>
<li>It is convertible to and from std::vector, usually without copying the elements. It is easy to provide APIs that accept either Array_&lt;T&gt; or std::vector&lt;T&gt;; the std::vector's data is referenced by an <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> handle that is used to convey the data across the API without binary compatibility problems.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>, <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a>, <a class="el" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ac67020459c021a6a6e076839105b1dd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3aed3ed93a6d406a35da0225352694b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef X <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adfe40f48092df9a7deafe32ef1ec39fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e344836dca88d0070ee505da9a628bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5efd5cd3092babe7a107b8efa664204"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e967f4929d463e32202d34158f3e22f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a05144fefe932d1c76e2e0dcaedddcd03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a47a140d8babac3edb92ff620e77245d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a9e2010641fb5df3c7e47c62a6db774"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a>&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a96b19c88ae09eec0ff5288e8e824d498"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a>&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7ed205f5372aad3ca9a8366441b16913"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt;X&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a5ca3b32f612044bed7552b7dc96164"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt;X&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1b7dc77f42cab3244ec808e5d4d3ee3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ArrayIndexPackType&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adc75b3e8df6112d5ea6fd77ad024bcc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor allocates no heap space and is very fast. </p>

</div>
</div>
<a class="anchor" id="a7a9e625487e34b5255619a492514926d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an array containing <em>n</em> default-constructed elements. </p>
<p>T's default constructor (if any) is called exactly <em>n</em> times. If <em>n</em> is zero no heap space will be allocated; although in that case it is preferable to use the default constructor if you can since that will be somewhat faster. </p>

</div>
</div>
<a class="anchor" id="ad758f8ef3bb565989a22c5456a34f3b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an array containing <em>n</em> elements each set to a copy of the given initial value. </p>
<p>T's copy constructor will be called exactly <em>n</em> times. If <em>n</em> is zero no space will be allocated. </p>

</div>
</div>
<a class="anchor" id="a730175ab17a18e5d87974ea97c712e3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class InputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; from a range [first,last1) of values identified by a pair of iterators. </p>
<dl class="section note"><dt>Note</dt><dd>The standard requires that if an integral type matches this signature, it must behave as the Array_(size_type,value_type) constructor. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>The performance of this constructor depends on the type of iterator:<ul>
<li>random_access_iterator: n=(last1-first); a single space allocation; n calls to T's copy constructor.</li>
<li>forward or bidirectional iterator: must increment from first to last1 to determine n; otherwise same as random access.</li>
<li>input iterator: can't determine n in advance; expect log n reallocations during construction as we "push back" one input element at a time. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a782b385c4c710cf60fc4205371c7d5cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; from a range [first,last1) of values identified by a pair of ordinary pointers to elements of type T2 (where T2 might be the same as T but doesn't have to be). </p>
<p>This is templatized so can be used with any source type T2 for which there is a working conversion constructor T(T2), provided that the number of source elements does not exceed the array's <a class="el" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array. ">max_size()</a>. </p>

</div>
</div>
<a class="anchor" id="a40d3d7fccc13d4d892ce52ebccdf4acc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; by copying from an std::vector&lt;T2&gt;, where T2 may be the same type as T but doesn't have to be. </p>
<p>This will work as long as the size of the vector does not exceed the array's <a class="el" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array. ">max_size()</a>, and provided there is a working T(T2) conversion constructor. </p>

</div>
</div>
<a class="anchor" id="afe60949157ed425b6b81b7ff0e11ca29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor allocates exactly as much memory as is in use in the source (not its capacity) and copy constructs the elements so that T's copy constructor will be called exactly src.size() times. </p>
<p>If the source is empty, no heap space will be allocated. </p>

</div>
</div>
<a class="anchor" id="af66a2741c555a387d09742b9a5517314"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct this Array_&lt;T,X&gt; as a copy of another Array_&lt;T2,X2&gt; where T2!=T or X2!=X. </p>
<p>This will work as long as the source is not larger than will fit here, and as long as the source element type T2 is assignment compatible with this array's element type T. One of T's constructors will be called exactly src.size() times; the particular constructor is whichever one best matches T(T2). </p>

</div>
</div>
<a class="anchor" id="a53d115efe0bc7dafba02b3d04562dd92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSimTK_1_1DontCopy.html">DontCopy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; by referencing (sharing) a given range of data [first,last1), without copying that data; better to use the corresponding ArrayView_&lt;T&gt; constructor if you can. </p>
<p>This is very fast but can be dangerous &ndash; it is most useful for argument passing where the array handle will be discarded immediately after use. Note that this is available only if you have write access to the data because there is no way to construct a non-writable array. This will work as long as the size of the data does not exceed the array's max_size. The resulting array object is not resizeable but can be used to read and write elements of the original data. The array is invalid if the original data is destructed or resized, but there is no way for the array class to detect that.</p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>If the source data is empty, the resulting array will also be empty and will look just like a default-constructed array. It will therefore not have any connection to the source and will be an ordinary resizable array.</li>
<li>This is quite dangerous to use since the connection between the array and the data is tenuous and subject to the data remaining untouched during the lifetime of the array handle. There is no reference counting; destructing the original data would leave the array referring to garbage. Be careful!</li>
<li>You can break the connection between the array and the data it was constructed from by calling <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Dirt cheap. There will be no construction, destruction, or heap allocation performed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3331ee7155535eeac08b7297da16ebe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSimTK_1_1DontCopy.html">DontCopy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; by referencing (sharing) the data in an std::vector&lt;T&gt;, without copying the data; better to use the ArrayView_&lt;T&gt; constructor instead if you can. </p>
<p>This is very fast but can be dangerous &ndash; it is most useful for argument passing where the array handle will be discarded immediately after use. Note that this is available only if you have write access to the std::vector because there is no way to construct a non-writable array. This will work as long as the size of the vector does not exceed the array's max_size. The resulting array object is not resizeable but can be used to read and write elements of the original std::vector. The array is invalid if the original std::vector is destructed or resized.</p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>If the source std::vector is empty, the resulting array will also be empty and will look just like a default-constructed array. It will therefore not have any connection to the source vector and will be an ordinary resizable array.</li>
<li>This is quite dangerous to use since the connection between the array and the vector is tenuous and subject to the vector remaining untouched during the lifetime of the array handle. There is no reference counting; destructing the vector leaves the array referring to garbage. Be careful!</li>
<li>You can break the connection between the array and the vector it was constructed from by calling <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Dirt cheap. There will be no construction, destruction, or heap allocation performed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad55d3b71e2acdaa0f2bb8be2617c894f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::~<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor performs a <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> operation which may result in element destruction and freeing of heap space; see <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> for more information. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a67bc6c09d3ea513dfba42a5dfc42cd38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty this array of its contents, returning the array to its default-constructed, all-zero state. </p>
<p>If this array is the owner of its data, the destructor (if any) is called for each data element and the array's allocated heap space is freed. If it is a non-owner the array handle is cleaned out using <a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc" title="Forward to base class disconnect() method  clears the handle without doing anything to the data...">disconnect()</a> but the referenced data is untouched. </p><dl class="section note"><dt>Note</dt><dd>There is no equivalent to this method for std::vector. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the now-empty, default-constructed array, ready for reassignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a136a03677c28d7ee697df7e09b7aa2e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this array to be <em>n</em> copies of the supplied <em>fillValue</em>. </p>
<p>Note that this serves to allow fill from an object whose type T2 is different from T, as long as there is a constructor T(T2) that works since that can be invoked (implicitly or explicitly) to convert the T2 object to type T prior to the call. If this is a non-owner array then <em>n</em> must be the same as the current <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a>; consider using the <a class="el" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab" title="Assign all current elements of the array to the same fillValue. ">fill()</a> method instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements to be in the result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fillValue</td><td>The value to which to initialize each element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>n</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array. ">max_size()</a> </dd>
<dd>
for non-owner, n==<a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>For a non-owner with <em>n==<a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a></em>, there will be exactly <em>n</em> calls to T's copy assignment operator. For an owner, there will be <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> calls to T's destructor (if it has one), possibly a heap reallocation (but with no element copying), followed by <em>n</em> calls to T's copy constructor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab" title="Assign all current elements of the array to the same fillValue. ">fill()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a66cc4a2796075ec7a3097bcc6d616bab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign all current elements of the array to the same <em>fillValue</em>. </p>
<p>This is similar to assign(size(),fillValue) but the semantics are subtly different. Here we use repeated application of T's copy assignment operator T=fillValue, whereas the <a class="el" href="classSimTK_1_1Array__.html#a136a03677c28d7ee697df7e09b7aa2e2" title="Set this array to be n copies of the supplied fillValue. ">assign()</a> semantics are to first destruct all the existing elements, then allocate if necessary, then use the copy constructor to initialize the new elements. Note that you can use this to fill from a source type T2 that is different from T as long as there exists a suitable constructor T(T2) that can be used to create the type T <em>fillValue</em> from the original T2 source. </p><dl class="section note"><dt>Note</dt><dd>Unlike other assignment methods, the behavior of <a class="el" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab" title="Assign all current elements of the array to the same fillValue. ">fill()</a> is identical for owner and non-owner arrays.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fillValue</td><td>The value to which all existing elements are set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>Just <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> calls to T's copy assignment operator. </dd></dl>

</div>
</div>
<a class="anchor" id="a1614ce819a2a4221c0a072ffbc2a0935"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign to this array to to make it a copy of the elements in range [first,last1) given by ordinary pointers. </p>
<p>It is not allowed for this range to include any of the elements currently in the array. The source elements can be of a type T2 that may be the same or different than this array's element type T as long as there is a working constructor T(T2) (for owner arrays) or a working assignment operator T=T2 (for non-owner arrays). Note that although the source arguments are pointers, those may be iterators for some container depending on implementation details of the container. Specifically, any <a class="el" href="classSimTK_1_1Array__.html#a05144fefe932d1c76e2e0dcaedddcd03">Array_&lt;T2&gt;::iterator</a> or const_iterator is an ordinary pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>A pointer to the first source element to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>A pointer to one element past the last source element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>For non-owner arrays, n=last1-first must equal the current <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> in which case there will be exactly <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> calls to the T=T2 assignment operator. For owner arrays, say the array initially has capacity c, and the source provides n new elements. If type T has a destructor, it will be called exactly <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> times. Reallocation will then occur if c &lt; n and may occur if c &gt;&gt; n to avoid leaving a lot of unused space. Then the constructor T(T2) will be called exactly n times. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0fbbed70bc0fdb3ec5c188193503bb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign this array from a range [first,last1) given by non-pointer iterators. </p>
<p>See the assign(first,last1) method with pointer arguments for a relevant discussion.</p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>For a non-owner array this is only allowed if we can calculate the number of source elements, and if that number is exactly the same as the current <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a>.</li>
<li>See Complexity discussion below for behavior for the different kinds of iterators that might be supplied.</li>
<li>It is not permitted for any of the source elements to overlap in memory with the initial contents of the array.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator pointing to the first source element to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>A iterator pointing one element past the last source element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>last1-first &lt;= <a class="el" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array. ">max_size()</a> </dd>
<dd>
for non-owner array, last1-first == <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>For a non-owner array, this is only allowed if n=last1-first equals the current <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a>, in which case we'll perform exactly n calls to the appropriate assignment operator of element type T. For owner arrays, if we can determine how many elements n=last1-first the source contains in advance, we'll do only a single allocation here and call one of T's constructors exactly n times after just <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> destructor calls needed to erase the original data. If the iterators are random access iterators, calculating n is a fast constant-time operation. For forward or bidirectional iterators, we have to advance through the iterators once to count the source elements prior to allocating space, adding an O(n) cost. For input iterators, we can't count them in advance so we just have to add elements as we find them using <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back()</a> meaning we may need to reallocate log(n) times, calling the destructor and copy constructor each time to move the elements around. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>assign(T2* first, T2* last1) </dd></dl>

</div>
</div>
<a class="anchor" id="a17aa8ec53fbbd5af9d8311040b4e215a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator destructs the current contents of this array and then makes it a copy of the source array by repeated calls to the element type's copy constructor. </p>
<p>At most one reallocation of heap space occurs that may result in this array having a larger or smaller capacity, although of course it will be at least as large as the source. </p>

</div>
</div>
<a class="anchor" id="a31782606c119d1db301ef14a930abd22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is assignment from a source array whose element type T2 and/or index type X2 are different from this array's T and X. </p>
<p>This will work as long as this array can accommodate all the elements in the source and T2 is assignment compatible with T. See discussion for the copy assignment operator for more information. </p>

</div>
</div>
<a class="anchor" id="abada82afde9d55dbde8b44052ce1fda1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T2, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is assignment from a source std::vector&lt;T2&gt;. </p>
<p>This will work as long as this array can accommodate all the elements in the source and T2 is assignment compatible with T. See discussion for the copy assignment operator for more information. </p>

</div>
</div>
<a class="anchor" id="a4c544ef3a4eee81c7580699e793e0f92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a specialized algorithm providing constant time exchange of data with another array that has identical element and index types. </p>
<p>This is <em>much</em> faster than using the std::swap() algorithm on the arrays since that would involve O(n) copying operations. This method makes no calls to any constructors or destructors. This is allowable even for non-owner arrays; the non-owner attribute will follow the non-owned data. </p>

</div>
</div>
<a class="anchor" id="ac5671ab71d22a14e65a149feea9c577a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::adoptData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>dataCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This dangerous extension allows you to supply your own already-allocated heap space for use by this array, which then becomes the owner of the supplied heap space. </p>
<p>Any memory currently associated with the array is deallocated; see <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> for more information. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a>, <a class="el" href="classSimTK_1_1Array__.html#a3e51e9d13453755cb0cce47af007d3c7" title="This dangerous extension allows you to make this array handle refer to someone else&#39;s data without co...">shareData()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37550aafe7e3c54f9604ff80479153e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::adoptData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a" title="This dangerous extension allows you to supply your own already-allocated heap space for use by this a...">adoptData()</a> that assumes the capacity is the same as the current size. </p>
<dl class="section see"><dt>See also</dt><dd>adoptData(data,size,capacity) </dd></dl>

</div>
</div>
<a class="anchor" id="a3e51e9d13453755cb0cce47af007d3c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::shareData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This dangerous extension allows you to make this array handle refer to someone else's data without copying it. </p>
<p>Any memory currently associated with the array is deallocated; see <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> for more information. This method makes the array a fixed-size, non-owner array that cannot be reallocated, and no element destruction nor heap deallocation will occur when the handle is subsequently destructed or deallocated. </p><dl class="section note"><dt>Note</dt><dd><ul>
<li>A null (0) pointer is allowed for the pointer as long as <em>dataSize==0</em>, however in that case the array handle ends up deallocated (that is, indistinguishable from a default-constructed array) so is resizeable.</li>
<li>This is implemented by setting the nAllocated data member to zero while the nUsed data member is set to the given <em>dataSize</em>. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a>, <a class="el" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a" title="This dangerous extension allows you to supply your own already-allocated heap space for use by this a...">adoptData()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa780ca6f8edd609cd461b0a90fbbca64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::shareData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as shareData(data,size) but uses a pointer range [first,last1) to identify the data to be referenced. </p>

</div>
</div>
<a class="anchor" id="a00d92f7cb1c2c6ad7d8ff7267a67ee0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current number of elements stored in this array. </p>

</div>
</div>
<a class="anchor" id="aa7f29e36968740e433a451cb82774046"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum allowable size for this array. </p>

</div>
</div>
<a class="anchor" id="a41c0aa10d7095ff4a6c385a5f408b170"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if there are no elements currently stored in this array. </p>
<p>This is equivalent to the tests <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> == <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> or <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a>==0. </p>

</div>
</div>
<a class="anchor" id="a7d905825b941637a97453cba165f0feb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements this array can currently hold without requiring reallocation. </p>
<p>The value returned by <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> is always greater than or equal to <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a>, even if the data is not owned by this array in which case we have <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> == <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> and the array is not reallocatable. </p>

</div>
</div>
<a class="anchor" id="a3ef48cf9aac351db79f747c2ddd23bf4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the size of this Array, preserving all the elements that will still fit, and default constructing any new elements that are added. </p>
<p>This is not allowed for non-owner arrays unless the requested size is the same as the current size. </p>

</div>
</div>
<a class="anchor" id="ab839b023c760816f9580d4feea2c9136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the size of this array, preserving all the elements that will still fit, and initializing any new elements that are added by repeatedly copy- constructing from the supplied value. </p>
<p>This is not allowed for non-owner arrays unless the requested size is the same as the current size. </p>

</div>
</div>
<a class="anchor" id="a18b9cb15ea07f2da45d9b45a8f12429e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that this array has enough allocated capacity to hold the indicated number of elements. </p>
<p>No heap reallocation will occur after this until the array is grown beyond this capacity, meaning that adding elements will not invalidate any iterators or element addresses until that point. This method will never reduce the capacity of the array. It is OK to call this on a non-owner array as long as you are not asking for an increase in capacity. </p>

</div>
</div>
<a class="anchor" id="aad5af2017b0c5a1a2160104d98a59294"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request that the capacity of this array be reduced to the minimum necessary to hold the number of elements currently in use. </p>
<p>In practice no shrinkage will occur if the current size is just slightly too big, unless the current size is exactly zero in which case we guarantee to deallocate all heap space associated with this array leaving a null data pointer and <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a>==<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>==0, exactly as though the array had just been default-constructed. Otherwise you can check <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> afterwards to see what happened. If the <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> is reduced by this method, then all the elements will have been moved to new locations so existing iterators and references into the array will become invalid.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This method is from the proposed C++0x standard for std::vector, except for the guaranteed behavior for a zero-size container.</li>
<li>It is OK to call this on a non-owner array but it has no effect since <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a>==<a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> already in that case.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>If the capacity is reduced, there will be one call to T's copy constructor and destructor (if any) for each element currently in the array. Otherwise this is very fast. </dd></dl>

</div>
</div>
<a class="anchor" id="ab09f12c0986ba2025ece82fa7fe5df41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::allocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the amount of heap space owned by this array; this is the same as <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> for owner arrays but is zero for non-owners. </p>
<dl class="section note"><dt>Note</dt><dd>There is no equivalent of this method for std::vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a82f384696e84727ee28902212fc95a1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::isOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this array own the data to which it refers? If not, it can't be resized, and the destructor will not free any heap space nor call any element destructors. </p>
<p>If the array does not refer to <em>any</em> data it is considered to be an owner and it is resizeable. </p><dl class="section note"><dt>Note</dt><dd>There is no equivalent of this method for std::vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f009675fdf90d112f15279b35da6688"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>, which may be null (0) in that case but does not have to be. </p>
<p>This method is from the proposed C++0x standard; there is also an overloaded <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> from the original standard that returns a const pointer. </p>

</div>
</div>
<a class="anchor" id="a8b25d6dc2485899425d6a4c96d574ed0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#a1f009675fdf90d112f15279b35da6688" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a>. </p>

</div>
</div>
<a class="anchor" id="ab87a252bd681eeb8d9e4075343263f1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </p>
<p>If the array is empty, this <em>may</em> return null (0) but does not have to &ndash; the only thing you can be sure of is that <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> == <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> for an empty array. </p>

</div>
</div>
<a class="anchor" id="a3758a3dc3ecebc1eeea89d389c049253"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be. </p>
<p>This method is from the proposed C++0x standard; there is also an overloaded <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> from the original standard that returns a const pointer. </p>

</div>
</div>
<a class="anchor" id="a06a9152d785cb3d350e624d53d49af08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>. </p>

</div>
</div>
<a class="anchor" id="a5a12efc66437667e7af14e54747433ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to what would be the element just after the last one in this array. </p>
<p>If the array is empty, this <em>may</em> return null (0) but does not have to &ndash; the only thing you can be sure of is that <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a>==<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> for an empty array. </p>

</div>
</div>
<a class="anchor" id="af9f884619b7afeb2c4e31be0ac9a5c96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1Array__.html#a936220808b01ffe9e5080cf97cf67409" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty. </p>

</div>
</div>
<a class="anchor" id="a09a9b5657f95c864088caa629bbb14c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1Array__.html#aab002eb8f193aea7d6b4ab3683ff89aa" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#af9f884619b7afeb2c4e31be0ac9a5c96" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>. </p>

</div>
</div>
<a class="anchor" id="aab002eb8f193aea7d6b4ab3683ff89aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> if the array is empty. </p>

</div>
</div>
<a class="anchor" id="a936220808b01ffe9e5080cf97cf67409"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array. </p>
<p>You cannot dereference this iterator. </p>

</div>
</div>
<a class="anchor" id="af6614217a1df42b91aa38cb3ea7ec61d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#a936220808b01ffe9e5080cf97cf67409" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>. </p>

</div>
</div>
<a class="anchor" id="a5973f198607a6531235df6877ab9979d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array. </p>
<p>You cannot dereference this iterator. </p>

</div>
</div>
<a class="anchor" id="ace9ac236751f99b1663c504ae87d3a2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ace9ac236751f99b1663c504ae87d3a2b" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a> does not appear to be in the C++0x standard although it would seem obvious in view of the <a class="el" href="classSimTK_1_1Array__.html#a1f009675fdf90d112f15279b35da6688" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a> and <a class="el" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a> methods that had to be added. The C++0x overloaded const <a class="el" href="classSimTK_1_1Array__.html#af05128fb7611eb19f884b1e742878277" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is also available. </dd></dl>

</div>
</div>
<a class="anchor" id="aecd7415f4c933c8c572d93b486193c26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of the <a class="el" href="classSimTK_1_1Array__.html#af05128fb7611eb19f884b1e742878277" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is identical to <a class="el" href="classSimTK_1_1Array__.html#ace9ac236751f99b1663c504ae87d3a2b" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This method is from the proposed C++0x std::vector. </dd></dl>

</div>
</div>
<a class="anchor" id="af05128fb7611eb19f884b1e742878277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the first allocated element of the array, or a null pointer if no space is associated with the array. </p>
<dl class="section note"><dt>Note</dt><dd>This method is from the proposed C++0x std::vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6db339c90590b6a6c230c2ebaa63141"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element by its index, returning a const reference. </p>
<p>Note that only a value of the Array's templatized index type is allowed (default is unsigned). This will be range-checked in a Debug build but not in Release. </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a52dc3c8d6816f2cc3d9e42caa2688993"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element by its index, returning a writable (lvalue) reference. </p>
<p>Note that only a value of the Array's templatized index type is allowed (default is unsigned). This will be range-checked in a Debug build but not in Release. </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="ab62d24dae1b22b621da114318134d55e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as operator[] but always range-checked, even in a Release build. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8a43460f045aeb40cc0e1ca44aacbc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as operator[] but always range-checked, even in a Release build. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e442e44a784734db4d3750c24d17ac1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::getElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed. </p>

</div>
</div>
<a class="anchor" id="aa17ec9fa947bdc8b7aa75a0d09b36214"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::updElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the non-const form of operator[]; exists to provide a non-operator method for element access in case that's needed. </p>

</div>
</div>
<a class="anchor" id="a8d24987c3a2d57c2ceb5e0d3f15f73b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the first element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e306ed9d706676046787b8f8c049480"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the first element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a251212be7a0d7adaa5f9f72d8a694a64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the last element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="af001d2418473e4e149969b0aea2ac96a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the last element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a88a623121405c9896be85477f4cb4953"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt;T,X&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select a subrange of this const array by starting index and length, and return a <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> referencing that data without copying it. </p>

</div>
</div>
<a class="anchor" id="a8471d7b2c924d3704fbd54ab10451c19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt;T,X&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::getSubArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as const form of operator()(index,length); exists to provide non-operator access to that functionality in case it is needed. </p>

</div>
</div>
<a class="anchor" id="a9cbd317755142dd7707305ba1dd36c4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt;T,X&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select a subrange of this array by starting index and length, and return an <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> referencing that data without copying it. </p>

</div>
</div>
<a class="anchor" id="a223502957a0d38152ea9bda9ac194829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt;T,X&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::updSubArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as non-const operator()(index,length); exists to provide non-operator access to that functionality in case it is needed. </p>

</div>
</div>
<a class="anchor" id="a13b95bc701e5bd09dad7ee38e069b669"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method increases the size of the Array by one element at the end and initializes that element by copy constructing it from the given value. </p>
<p>If <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> &gt; <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a>, that's all that will happen. If <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a>==<a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a>, there is no room for another element so we'll allocate more space and move all the elements there. A reference to the just-inserted element can be obtained using the <a class="el" href="classSimTK_1_1Array__.html#af001d2418473e4e149969b0aea2ac96a" title="Return a writable reference to the last element in this array, which must not be empty. ">back()</a> method after the call to <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>An object of type T from which the new element is copy-constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>If you are appending a default-constructed object of type T, consider using the alternate non-standard but safe <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back()</a> method rather than push_back(T()). The non-standard method default-constructs the new element internally. That avoids a call to the copy constructor which can be expensive for some objects, and nonexistent for others.</li>
<li>If you are constructing the source object with a non-default constructor, and the object is expensive or impossible to default-construct and/or copy-construct, consider using the non-standard and dangerous method <a class="el" href="classSimTK_1_1Array__.html#a7ceb31ef48594914eaef9ddcec92791c" title="This dangerous method increases the Array&#39;s size by one element at the end but doesn&#39;t perform any co...">raw_push_back()</a> which enables you to construct the new element in place.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time if no reallocation is required; otherwise the current contents of the array must be copied to new space, costing one call to T's copy constructor and destructor (if any) for each element currently in the array. Either way there is also one call to T's copy constructor to construct the new element from the supplied value. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b698ae20b857ce3de014b8996f3b1e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::push_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a non-standard version of <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back()</a> that increases the size of the array by one default-constructed element at the end. </p>
<p>This avoids having to default-construct the argument to the standard push_back(value) method which then has to copy-construct it into the array. By carefully avoiding reallocation and using this form of <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back()</a> you can use the Array_&lt;T&gt; class to hold objects of type T even if T has no copy constructor, which is prohibited by the standard std::vector&lt;T&gt; definition.</p>
<dl class="section user"><dt>Complexity:</dt><dd>Same as the standard push_back(value) method except without the final call to T's copy constructor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>push_back(value) </dd></dl>

</div>
</div>
<a class="anchor" id="a7ceb31ef48594914eaef9ddcec92791c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::raw_push_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This dangerous method increases the Array's size by one element at the end but doesn't perform any construction so the memory is filled with garbage. </p>
<p>You must immediately construct into this space, using code like: </p><div class="fragment"><div class="line"><span class="keyword">new</span>(a.raw_push_back()) MyConstructor(...args...);       </div></div><!-- fragment --><p> This is a substantial performance improvement when the element type is something complicated since the constructor is called once and not copied; it can also be used for objects that have neither default nor copy constructors. </p><dl class="section return"><dt>Returns</dt><dd>An iterator (pointer) pointing at the unconstructed element. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Same as ordinary <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>push_back(value), <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a54b5b478c9ac203ed767eadf7828ffcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last element from this array, which must not be empty. </p>
<p>The element is destructed, not returned. The array's <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> is reduced by one. </p>

</div>
</div>
<a class="anchor" id="a52a656cb3128af0259d85978a61b7e01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements in range [first,last1), packing in any later elements into the newly-available space and reducing the array's size by the number of elements erased. </p>
<p>Capacity is unchanged. If the range is empty nothing happens.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>first</em> &lt;= <em>last1</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Points to the first element that will be erased. </td></tr>
    <tr><td class="paramname">last1</td><td>Points one element past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element immediately following the erased ones, or <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> if there are none. Either way, this is the same memory address as the passed-in <em>first</em> argument since there can be no reallocation here. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Calls T's destructor once for each erased element and calls T's copy constructor and destructor once for each element that has to be moved. </dd></dl>

</div>
</div>
<a class="anchor" id="a818361e237b91adc12d2122f119c579c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase just one element, moving all subsequent elements down one slot and reducing the array's size by one. </p>
<p>This is equivalent to erase(p,p+1) but faster; that means <em>p</em> cannot be <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> because <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>+1 is not defined. Capacity is unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>If you don't mind the elements being reordered, you can erase an element in constant time using the non-standard extension <a class="el" href="classSimTK_1_1Array__.html#aea3f2ff76ae0b004c5e21c3aa170ebf6" title="Be careful with this non-standard extension; it erases one element and then moves the last one in its...">eraseFast()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Points to the element that will be erased; <em>p</em> cannot be <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the element that replaced the one at <em>p</em>, or <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> if <em>p</em> was the last element. Either way, this is the same memory address as the erased element had since there can be no reallocation here. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Calls T's destructor once for the erased element and calls T's copy constructor and destructor once for each element that has to be moved. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#aea3f2ff76ae0b004c5e21c3aa170ebf6" title="Be careful with this non-standard extension; it erases one element and then moves the last one in its...">eraseFast()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aea3f2ff76ae0b004c5e21c3aa170ebf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::eraseFast </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Be careful with this non-standard extension; it erases one element and then moves the last one in its place which changes the element order from what it was before (unlike the standard <a class="el" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase()</a> method). </p>
<p>This avoids having to compress the elements so this runs in constant time: the element is destructed; then if it wasn't the last element the copy constructor is used to copy the last element into the vacated space, and the destructor is called to clear the last element. The size is reduced by 1 but the capacity does not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Points to the element that will be erased; <em>p</em> cannot be <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the element that replaced the one at <em>p</em>, or <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> if <em>p</em> was the last element. Either way, this is the same memory address as the erased element had since there can be no reallocation here. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Calls T's destructor once for the erased element and calls T's copy constructor and destructor once for each element that has to be moved. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af95f49692c338895df4ddc36752b4baa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all the elements currently in this array without changing the capacity; equivalent to erase(<a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a>,<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>) but a little faster. </p>
<p>Size is zero after this call. T's destructor is called exactly once for each element in the array.</p>
<dl class="section user"><dt>Complexity:</dt><dd>O(n) if T has a destructor; constant time otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c6c04b85ed597b657f4cd244c02c52d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>n</em> copies of a given value at a particular location within this array, moving all following elements up by <em>n</em> positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Where to insert the new elements. This must be an iterator (pointer) that is valid for this array, that is, <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>How many copies of the given <em>value</em> to insert. Nothing happens if <em>n</em> is zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A value of the element type that is copied into the newly-created elements using T's copy constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first of the newly-created elements in the array. This will be different from <em>p</em> if reallocation occurred, otherwise it is the same as <em>p</em> was on entry.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>If <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> + <em>n</em> &gt; <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> then the array must be reallocated, resulting in <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> copy constructor/destructor call pairs to move the old data to the new location. Otherwise, the m=(<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>-<em>p</em>) elements above the insertion point must be moved up <em>n</em> positions resulting in m copy/destruct pairs. Then there are n additional copy constructor calls to construct the new elements from the given value. </dd></dl>

</div>
</div>
<a class="anchor" id="a1de9710bd314b227b6d7fb9b1e2e5013"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new element at a given location within this array, initializing it to a copy of a given value and moving all following elements up one position. </p>
<p>This is identical to insert(<em>p</em>,1,<em>value</em>) but slightly faster; see that method for full documentation. </p>

</div>
</div>
<a class="anchor" id="a9e597a8ecd02706680bf8920c5a15f29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements in a range [first,last1) into this array at a given position <em>p</em>, moving all following elements up by n=(last1-first) positions. </p>
<p>This variant of <a class="el" href="classSimTK_1_1Array__.html#a7c6c04b85ed597b657f4cd244c02c52d" title="Insert n copies of a given value at a particular location within this array, moving all following ele...">insert()</a> takes iterators which are ordinary pointers, although the source elements do not have to be of type T as long as there is a constructor T(T2) that works.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Where to insert the new elements. This must be an iterator (pointer) that is valid for this array, that is, <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>This is a pointer to the first element of the source to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>This points one element past the last element of the source to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first of the newly-created elements in the array. This will be different from <em>p</em> if reallocation occurred, otherwise it is the same as <em>p</em> was on entry.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> </dd>
<dd>
first &lt;= last1 </dd>
<dd>
The range [first,last1) does not include any of the current contents of this array. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>If <a class="el" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> &lt; <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a>+n then the array must be reallocated, resulting in <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> calls to T's copy constructor and destructor (if any)to move the old data to the new location. Otherwise, the m=(<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>-<em>p</em>) elements above the insertion point must be moved up n positions resulting in m copy/destruct pairs. Then there are n additional copy constructor calls to construct the new elements from the given value. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2abd8e9d2146f344a88f96d1f839db0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements in a range [first,last1) where the range is given by non-pointer iterators. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a015cef5d8e534e632955fcca6ea444f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeUnformatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialize <a class="el" href="classSimTK_1_1Array__.html#a015cef5d8e534e632955fcca6ea444f8" title="Specialize writeUnformatted() for Array_&lt;E,X&gt; to delegate to element type E, with spaces separating t...">writeUnformatted()</a> for Array_&lt;E,X&gt; to delegate to element type E, with spaces separating the elements. </p>

</div>
</div>
<a class="anchor" id="a6abedbcfc5b21bd9fa859208247aec72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeFormatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialize <a class="el" href="classSimTK_1_1Array__.html#a6abedbcfc5b21bd9fa859208247aec72" title="Specialize writeFormatted() for Array_&lt;E,X&gt; to delegate to element type E, with surrounding parenthes...">writeFormatted()</a> for Array_&lt;E,X&gt; to delegate to element type E, with surrounding parentheses and commas separating the elements. </p>

</div>
</div>
<a class="anchor" id="a8575e59ff1ed3dcb8e52d7dd44ebb426"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output a human readable representation of an array to an std::ostream (like std::cout). </p>
<p>The format is ( <em>elements</em> ) where <em>elements</em> is a comma-separated list of the Array's contents output by invoking the "&lt;&lt;" operator on the elements. This function will not compile if the element type does not support the "&lt;&lt;" operator. No newline is issued before or after the output. </p>

</div>
</div>
<a class="anchor" id="a6b300ce2032c6315983114f0b7e84e92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool readUnformatted </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="classSimTK_1_1Array__.html#a6b300ce2032c6315983114f0b7e84e92" title="Specialization of readUnformatted() for variable-length Array_&lt;T,X&gt;; continues reading whitespace-sep...">readUnformatted()</a> for variable-length Array_&lt;T,X&gt;; continues reading whitespace-separated tokens until error or eof. </p>

</div>
</div>
<a class="anchor" id="a65a8a24c48ad3dff0c852095f0347941"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool readFormatted </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="classSimTK_1_1Array__.html#a65a8a24c48ad3dff0c852095f0347941" title="Specialization of readFormatted() for variable-length Array_&lt;T,X&gt;; uses readArrayFromStream() to cons...">readFormatted()</a> for variable-length Array_&lt;T,X&gt;; uses <a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15" title="Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values option...">readArrayFromStream()</a> to consume an appropriately-formatted array until error, closing parenthesis or bracket, or eof. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15" title="Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values option...">readArrayFromStream()</a> for details </dd></dl>

</div>
</div>
<a class="anchor" id="a0a452cab4756ae07c3ab22c155eb1b15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::istream &amp; readArrayFromStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values optionally surrounded by parentheses (), square brackets [], or curly braces {}. </p>
<p>We will continue to read elements of type T from the stream until we find a reason to stop, using type T's stream extraction <a class="el" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82" title="Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T...">operator&gt;&gt;()</a> to read in each element and resizing the Array as necessary. If the data is bracketed, we'll read until we hit the closing bracket. If it is not bracketed, we'll read until we hit eof() or get an error such as the element extractor setting the stream's fail bit due to bad formatting. On successful return, the stream will be positioned right after the final read-in element or terminating bracket, and the stream's status will be good() or eof(). We will not consume trailing whitespace after bracketed elements; that means the stream might actually be empty even if we don't return eof(). If you want to know whether there is anything else in the stream, follow this call with the STL whitespace skipper std::ws() like this: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15">readArrayFromStream</a>(in,array) &amp;&amp; !in.eof()) </div><div class="line">    std::ws(in); <span class="comment">// might take us to eof</span></div><div class="line"><span class="keywordflow">if</span> (in.fail()) {...} <span class="comment">// probably a formatting error</span></div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    <span class="comment">// Here if the stream is good() then there is more to read; if the</span></div><div class="line">    <span class="comment">// stream got used up the status is guaranteed to be eof().</span></div><div class="line">}</div></div><!-- fragment --><p> A compilation error will occur if you try to use this method on an Array_&lt;T&gt; for a type T for which there is no stream extraction <a class="el" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82" title="Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T...">operator&gt;&gt;()</a>. </p><dl class="section note"><dt>Note</dt><dd>If you want to fill an owner Array_&lt;T&gt; with a fixed amount of data from the stream, <a class="el" href="classSimTK_1_1Array__.html#a3ef48cf9aac351db79f747c2ddd23bf4" title="Change the size of this Array, preserving all the elements that will still fit, and default construct...">resize()</a> the array to the appropriate length and then use <a class="el" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce" title="Read in a fixed number of elements from a stream into an Array. ">fillArrayFromStream()</a> instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce" title="Read in a fixed number of elements from a stream into an Array. ">fillArrayFromStream()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a34546fb36b84171e76276a508121a3ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::istream &amp; fillArrayFromStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in a fixed number of elements from a stream into an Array. </p>
<p>We expect to read in exactly <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> elements of type T, using type T's stream extraction <a class="el" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82" title="Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T...">operator&gt;&gt;()</a>. This will stop reading when we've read <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> elements, or set the fail bit in the stream if we run out of elements or if any element's extract operator sets the fail bit. On successful return, all <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> elements will have been set, the stream will be positioned right after the final read-in element or terminating bracket, and the stream's status will be good() or eof(). We will not consume trailing whitespace after reading all the elements; that means the stream might actually be empty even if we don't return eof(). If you want to know whether there is anything else in the stream, follow this call with std::ws() like this: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce">fillArrayFromStream</a>(in,array))</div><div class="line">    <span class="keywordflow">if</span> (!in.eof()) std::ws(in); <span class="comment">// might take us to eof</span></div><div class="line"><span class="keywordflow">if</span> (in.fail()) {...} <span class="comment">// deal with I/O or formatting error</span></div><div class="line"><span class="comment">// Here if the stream is good() then there is more to read; if the</span></div><div class="line"><span class="comment">// stream got used up the status is guaranteed to be eof().</span></div></div><!-- fragment --><p> A compilation error will occur if you try to use this method on an Array_&lt;T&gt; for a type T for which there is no stream extraction <a class="el" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82" title="Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T...">operator&gt;&gt;()</a>. </p><dl class="section note"><dt>Note</dt><dd>If you want to read in a variable number of elements and have the Array_&lt;T&gt; resized as needed, use <a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15" title="Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values option...">readArrayFromStream()</a> instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15" title="Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values option...">readArrayFromStream()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adbd40fd273bd41041bb7138a3268ca82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T, optionally delimited by parentheses, brackets, or braces. </p>
<p>The Array_&lt;T&gt; may be an owner (variable size) or a view (fixed size n). In the case of an owner, we'll read all the elements in brackets or until eof if there are no brackets. In the case of a view, there must be exactly n elements in brackets, or if there are no brackets we'll consume exactly n elements and then stop. Each element is read in with its own operator "&gt;&gt;" so this won't work if no such operator is defined for type T. </p>

</div>
</div>
<a class="anchor" id="a1e25d47eeb9e34faa78ee38812b194d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> objects are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T1==T2. </p>

</div>
</div>
<a class="anchor" id="aa79b082dbed61adf809400e05027c595"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The not equal operator is implemented using the equal operator. </p>

</div>
</div>
<a class="anchor" id="a0e1218fae627e26b17ed948a62e87cc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> objects are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter array (in which case the shorter one is "less than" the longer). </p>
<p>This depends on T1==T2 and T1&lt;T2 operators working. </p>

</div>
</div>
<a class="anchor" id="ad80423b9a73fd93e07d8465c97e999af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than or equal operator is implemented using the less than operator. </p>

</div>
</div>
<a class="anchor" id="ac93cc22c503f9f75f1be2cbbb2c97714"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1. </p>

</div>
</div>
<a class="anchor" id="a8822b4815845e58a47af6b5720791698"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The less than or equal operator is implemented using the greater than operator. </p>

</div>
</div>
<a class="anchor" id="a39975ed123e3738da698ea6d0ddc7a4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An Array_&lt;T1&gt; and an std::vector&lt;T2&gt; are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T1==T2. </p>

</div>
</div>
<a class="anchor" id="a5bef2d3446751e985a922ecb0681653c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An std::vector&lt;T1&gt; and an Array_&lt;T2&gt; are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T2==T1. </p>

</div>
</div>
<a class="anchor" id="a688f8af308de34d0431205f7d854aee3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The not equal operator is implemented using the equal operator. </p>

</div>
</div>
<a class="anchor" id="a7d04f55c1a275128219e677a974254c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The not equal operator is implemented using the equal operator. </p>

</div>
</div>
<a class="anchor" id="addbec0e1348a20404c060b9c5523544f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An Array_&lt;T1&gt; and std::vector&lt;T2&gt; are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter container (in which case the shorter one is "less than" the longer). </p>
<p>This depends on having working element operators T1==T2 and T1&lt;T2. </p>

</div>
</div>
<a class="anchor" id="aa929813dea46bf41f7ffee7053566f86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An std::vector&lt;T1&gt; and Array_&lt;T2&gt; are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter container (in which case the shorter one is "less than" the longer). </p>
<p>This depends on having working element operators T1==T2 and T1&lt;T2. </p>

</div>
</div>
<a class="anchor" id="a81e151401cab82f28a4d2f6c43bdaeb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than or equal operator is implemented using the less than operator. </p>

</div>
</div>
<a class="anchor" id="a1c9fc6fb86e0e02b422ea858ba216f94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than or equal operator is implemented using the less than operator. </p>

</div>
</div>
<a class="anchor" id="ad057e98ddbd0b80ab053519caa9dd2ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1. </p>

</div>
</div>
<a class="anchor" id="ad7d14e73a05783839ed5c679278764d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1. </p>

</div>
</div>
<a class="anchor" id="ad6219dc0d49e5f4d40d4a5d7954c5adb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The less than or equal operator is implemented using the greater than operator. </p>

</div>
</div>
<a class="anchor" id="a463986b88adfd8319e9a2ddcb7b21d0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The less than or equal operator is implemented using the greater than operator. </p>

</div>
</div>
<a class="anchor" id="a8a1771c28a26738d4e217ec67586f9c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a specialization of the STL std::swap() algorithm which uses the constant time built-in <a class="el" href="classSimTK_1_1Array__.html#a4c544ef3a4eee81c7580699e793e0f92" title="This is a specialized algorithm providing constant time exchange of data with another array that has ...">swap()</a> member of the <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> class. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Array_8h_source.html">Array.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Array__.html">Array_</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:05 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
