<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::BicubicSurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1BicubicSurface.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSimTK_1_1BicubicSurface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::BicubicSurface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class will create a smooth surface that approximates a two-argument function F(X,Y) from a given set of samples of that function on a rectangular grid with regular or irregular spacing.  
 <a href="classSimTK_1_1BicubicSurface.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html">PatchHint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object is used to hold precalculated data about the most recently accessed patch to accelerate the common case of repeated access to the same patch or to nearby patches.  <a href="classSimTK_1_1BicubicSurface_1_1PatchHint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa008066f4580100b06fdd8295575e1ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#aa008066f4580100b06fdd8295575e1ae">BicubicSurface</a> ()</td></tr>
<tr class="memdesc:aa008066f4580100b06fdd8295575e1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an uninitialized <a class="el" href="classSimTK_1_1BicubicSurface.html" title="This class will create a smooth surface that approximates a two-argument function F(X...">BicubicSurface</a> handle.  <a href="#aa008066f4580100b06fdd8295575e1ae">More...</a><br /></td></tr>
<tr class="separator:aa008066f4580100b06fdd8295575e1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74dc99f9f114096cd903a509f938f65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#ac74dc99f9f114096cd903a509f938f65">~BicubicSurface</a> ()</td></tr>
<tr class="memdesc:ac74dc99f9f114096cd903a509f938f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor deletes the underlying surface if there are no more handles referencing it, otherwise does nothing.  <a href="#ac74dc99f9f114096cd903a509f938f65">More...</a><br /></td></tr>
<tr class="separator:ac74dc99f9f114096cd903a509f938f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd80198bbcc78bb0fd9b8e79b1a0e9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a5dd80198bbcc78bb0fd9b8e79b1a0e9b">BicubicSurface</a> (const <a class="el" href="classSimTK_1_1BicubicSurface.html">BicubicSurface</a> &amp;source)</td></tr>
<tr class="memdesc:a5dd80198bbcc78bb0fd9b8e79b1a0e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor makes a shallow copy of <em>source</em>; the new handle will reference the same underlying surface as does <em>source</em>.  <a href="#a5dd80198bbcc78bb0fd9b8e79b1a0e9b">More...</a><br /></td></tr>
<tr class="separator:a5dd80198bbcc78bb0fd9b8e79b1a0e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63513b6232cbf46b9d63e06afce82135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1BicubicSurface.html">BicubicSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a63513b6232cbf46b9d63e06afce82135">operator=</a> (const <a class="el" href="classSimTK_1_1BicubicSurface.html">BicubicSurface</a> &amp;source)</td></tr>
<tr class="memdesc:a63513b6232cbf46b9d63e06afce82135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is shallow; it makes this handle reference the same underlying surface as does <em>source</em>.  <a href="#a63513b6232cbf46b9d63e06afce82135">More...</a><br /></td></tr>
<tr class="separator:a63513b6232cbf46b9d63e06afce82135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb540890a06e377b19171ca0b546316"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a4eb540890a06e377b19171ca0b546316">BicubicSurface</a> (const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;x, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;y, const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;f, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> smoothness=0)</td></tr>
<tr class="memdesc:a4eb540890a06e377b19171ca0b546316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a bicubic surface that approximates F(X,Y) given samples f(i,j) with the sample locations in f defined by the vectors x and y.  <a href="#a4eb540890a06e377b19171ca0b546316">More...</a><br /></td></tr>
<tr class="separator:a4eb540890a06e377b19171ca0b546316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dd87906575e90279703addf61f4c80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#ae9dd87906575e90279703addf61f4c80">BicubicSurface</a> (const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;spacing, const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;f, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> smoothness=0)</td></tr>
<tr class="memdesc:ae9dd87906575e90279703addf61f4c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a bicubic surface that approximates F(X,Y) given samples f(i,j) over a grid with regular spacing in both the x and y directions.  <a href="#ae9dd87906575e90279703addf61f4c80">More...</a><br /></td></tr>
<tr class="separator:ae9dd87906575e90279703addf61f4c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c85895c61c9a54329e9782efe1c9a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63">calcValue</a> (const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY, <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html">PatchHint</a> &amp;hint) const </td></tr>
<tr class="memdesc:a3c85895c61c9a54329e9782efe1c9a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value of the surface at a particular XY coordinate.  <a href="#a3c85895c61c9a54329e9782efe1c9a63">More...</a><br /></td></tr>
<tr class="separator:a3c85895c61c9a54329e9782efe1c9a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555d0b83780db1ca30104e8c33799c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a555d0b83780db1ca30104e8c33799c3c">calcValue</a> (const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY) const </td></tr>
<tr class="memdesc:a555d0b83780db1ca30104e8c33799c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a slow-but-convenient version of <a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63" title="Calculate the value of the surface at a particular XY coordinate. ">calcValue()</a> since it does not provide for a <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html" title="This object is used to hold precalculated data about the most recently accessed patch to accelerate t...">PatchHint</a>.  <a href="#a555d0b83780db1ca30104e8c33799c3c">More...</a><br /></td></tr>
<tr class="separator:a555d0b83780db1ca30104e8c33799c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be5d330c852f17455e01c3032af42b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a3be5d330c852f17455e01c3032af42b2">calcUnitNormal</a> (const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY, <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html">PatchHint</a> &amp;hint) const </td></tr>
<tr class="memdesc:a3be5d330c852f17455e01c3032af42b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the outward unit normal to the surface at a particular XY coordinate.  <a href="#a3be5d330c852f17455e01c3032af42b2">More...</a><br /></td></tr>
<tr class="separator:a3be5d330c852f17455e01c3032af42b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10acda40add5193fd5fc85f9c485774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#ab10acda40add5193fd5fc85f9c485774">calcUnitNormal</a> (const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY) const </td></tr>
<tr class="memdesc:ab10acda40add5193fd5fc85f9c485774"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a slow-but-convenient version of <a class="el" href="classSimTK_1_1BicubicSurface.html#a3be5d330c852f17455e01c3032af42b2" title="Calculate the outward unit normal to the surface at a particular XY coordinate. ">calcUnitNormal()</a> since it does not provide for a <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html" title="This object is used to hold precalculated data about the most recently accessed patch to accelerate t...">PatchHint</a>.  <a href="#ab10acda40add5193fd5fc85f9c485774">More...</a><br /></td></tr>
<tr class="separator:ab10acda40add5193fd5fc85f9c485774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ebf00891ff7c736ca2d78bb4ed7eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#ae4ebf00891ff7c736ca2d78bb4ed7eb4">calcDerivative</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;derivComponents, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY, <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html">PatchHint</a> &amp;hint) const </td></tr>
<tr class="memdesc:ae4ebf00891ff7c736ca2d78bb4ed7eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a partial derivative of this function at a particular point.  <a href="#ae4ebf00891ff7c736ca2d78bb4ed7eb4">More...</a><br /></td></tr>
<tr class="separator:ae4ebf00891ff7c736ca2d78bb4ed7eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf9739d4adbd415d664b3806f582508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#aedf9739d4adbd415d664b3806f582508">calcDerivative</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;derivComponents, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY) const </td></tr>
<tr class="memdesc:aedf9739d4adbd415d664b3806f582508"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a slow-but-convenient version of <a class="el" href="classSimTK_1_1BicubicSurface.html#ae4ebf00891ff7c736ca2d78bb4ed7eb4" title="Calculate a partial derivative of this function at a particular point. ">calcDerivative()</a> since it does not provide for a <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html" title="This object is used to hold precalculated data about the most recently accessed patch to accelerate t...">PatchHint</a>.  <a href="#aedf9739d4adbd415d664b3806f582508">More...</a><br /></td></tr>
<tr class="separator:aedf9739d4adbd415d664b3806f582508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60a9f46a6546d318736ee120aaca9a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#ac60a9f46a6546d318736ee120aaca9a0">isSurfaceDefined</a> (const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY) const </td></tr>
<tr class="memdesc:ac60a9f46a6546d318736ee120aaca9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The surface interpolation only works within the grid defined by the vectors x and y used in the constructor.  <a href="#ac60a9f46a6546d318736ee120aaca9a0">More...</a><br /></td></tr>
<tr class="separator:ac60a9f46a6546d318736ee120aaca9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646fd7a7126fc2ff3bc8cd32cb52555f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a646fd7a7126fc2ff3bc8cd32cb52555f">getMinXY</a> () const </td></tr>
<tr class="memdesc:a646fd7a7126fc2ff3bc8cd32cb52555f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lowest XY pair for which this surface is defined; that is the point (xmin,ymin).  <a href="#a646fd7a7126fc2ff3bc8cd32cb52555f">More...</a><br /></td></tr>
<tr class="separator:a646fd7a7126fc2ff3bc8cd32cb52555f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7c415eb760219aaa3d35a0c621846b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a1d7c415eb760219aaa3d35a0c621846b">getMaxXY</a> () const </td></tr>
<tr class="memdesc:a1d7c415eb760219aaa3d35a0c621846b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the highest XY pair for which this surface is defined; that is the point (xmax,ymax).  <a href="#a1d7c415eb760219aaa3d35a0c621846b">More...</a><br /></td></tr>
<tr class="separator:a1d7c415eb760219aaa3d35a0c621846b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac977fe3869878e3755a57a77d6aeae89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#ac977fe3869878e3755a57a77d6aeae89">createPolygonalMesh</a> (<a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> resolution=1) const </td></tr>
<tr class="memdesc:ac977fe3869878e3755a57a77d6aeae89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mesh that can be used to visualize this surface.  <a href="#ac977fe3869878e3755a57a77d6aeae89">More...</a><br /></td></tr>
<tr class="separator:ac977fe3869878e3755a57a77d6aeae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Statistics</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>This class keeps track of the number of surface accesses made (using either <a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63" title="Calculate the value of the surface at a particular XY coordinate. ">calcValue()</a> or <a class="el" href="classSimTK_1_1BicubicSurface.html#ae4ebf00891ff7c736ca2d78bb4ed7eb4" title="Calculate a partial derivative of this function at a particular point. ">calcDerivative()</a>, and how many of those were resolved successfully using some or all of the hint information.</p>
<p>Methods in this section allow access to those statistics. Note that these statistics include accesses from all users of this surface. </p>
</div></td></tr>
<tr class="memitem:ab1866dc5bad498298394448d158a82ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#ab1866dc5bad498298394448d158a82ff">getNumAccesses</a> () const </td></tr>
<tr class="memdesc:ab1866dc5bad498298394448d158a82ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the total number of calls made to either <a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63" title="Calculate the value of the surface at a particular XY coordinate. ">calcValue()</a> or <a class="el" href="classSimTK_1_1BicubicSurface.html#ae4ebf00891ff7c736ca2d78bb4ed7eb4" title="Calculate a partial derivative of this function at a particular point. ">calcDerivative()</a>.  <a href="#ab1866dc5bad498298394448d158a82ff">More...</a><br /></td></tr>
<tr class="separator:ab1866dc5bad498298394448d158a82ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508dd423a378bf14cbbef8bd9fc65db9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a508dd423a378bf14cbbef8bd9fc65db9">getNumAccessesSamePoint</a> () const </td></tr>
<tr class="memdesc:a508dd423a378bf14cbbef8bd9fc65db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the number of accesses which specified a point whose information was already available in the hint.  <a href="#a508dd423a378bf14cbbef8bd9fc65db9">More...</a><br /></td></tr>
<tr class="separator:a508dd423a378bf14cbbef8bd9fc65db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033a8e14d013727b53f2738d23d650bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a033a8e14d013727b53f2738d23d650bd">getNumAccessesSamePatch</a> () const </td></tr>
<tr class="memdesc:a033a8e14d013727b53f2738d23d650bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the number of accesses which specified a new point on the same patch as was already present in the hint, or asked for new information about the same point.  <a href="#a033a8e14d013727b53f2738d23d650bd">More...</a><br /></td></tr>
<tr class="separator:a033a8e14d013727b53f2738d23d650bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478468ab44e8ec34ff7dbb74a8a5bb38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a478468ab44e8ec34ff7dbb74a8a5bb38">getNumAccessesNearbyPatch</a> () const </td></tr>
<tr class="memdesc:a478468ab44e8ec34ff7dbb74a8a5bb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the number of accesses which specified on a point that was not on the patch currently in the hint, but was close enough that we did not have to do a general search.  <a href="#a478468ab44e8ec34ff7dbb74a8a5bb38">More...</a><br /></td></tr>
<tr class="separator:a478468ab44e8ec34ff7dbb74a8a5bb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e25c46d3d03cc1cb652523fd2e2b98d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a9e25c46d3d03cc1cb652523fd2e2b98d">resetStatistics</a> () const </td></tr>
<tr class="memdesc:a9e25c46d3d03cc1cb652523fd2e2b98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all statistics to zero.  <a href="#a9e25c46d3d03cc1cb652523fd2e2b98d">More...</a><br /></td></tr>
<tr class="separator:a9e25c46d3d03cc1cb652523fd2e2b98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The constructors here assume you have already computed the function values and derivatives.</p>
<p>Most users should use the constructors that construct this information automatically from given data points. </p>
</div></td></tr>
<tr class="memitem:ac57d7ec45bed3a0914ec9a4e5f053bba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#ac57d7ec45bed3a0914ec9a4e5f053bba">BicubicSurface</a> (const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;x, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;y, const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;f, const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;fx, const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;fy, const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;fxy)</td></tr>
<tr class="memdesc:ac57d7ec45bed3a0914ec9a4e5f053bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) A constructor for a bicubic surface that sets the partial derivatives of the surface to the values specified by fx, fy, and fxy.  <a href="#ac57d7ec45bed3a0914ec9a4e5f053bba">More...</a><br /></td></tr>
<tr class="separator:ac57d7ec45bed3a0914ec9a4e5f053bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c681c0997ea7f57896a4444a77e9cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a84c681c0997ea7f57896a4444a77e9cb">BicubicSurface</a> (const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;spacing, const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;f, const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;fx, const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;fy, const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;fxy)</td></tr>
<tr class="memdesc:a84c681c0997ea7f57896a4444a77e9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Same, but with regular grid spacing.  <a href="#a84c681c0997ea7f57896a4444a77e9cb">More...</a><br /></td></tr>
<tr class="separator:a84c681c0997ea7f57896a4444a77e9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1127d93ae5897e00484a349540702631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a1127d93ae5897e00484a349540702631">calcParaboloid</a> (const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY, <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html">PatchHint</a> &amp;hint, <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_SP, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k) const </td></tr>
<tr class="memdesc:a1127d93ae5897e00484a349540702631"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) For use with Hertz contact at a point Q we need to know the surface normal and principal curvature magnitudes and directions.  <a href="#a1127d93ae5897e00484a349540702631">More...</a><br /></td></tr>
<tr class="separator:a1127d93ae5897e00484a349540702631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa3bbd3a85c0a3c20198cc16b0a02ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#afaa3bbd3a85c0a3c20198cc16b0a02ca">calcParaboloid</a> (const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;XY, <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_SP, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k) const </td></tr>
<tr class="memdesc:afaa3bbd3a85c0a3c20198cc16b0a02ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) This is a slow-but-convenient version of <a class="el" href="classSimTK_1_1BicubicSurface.html#a1127d93ae5897e00484a349540702631" title="(Advanced) For use with Hertz contact at a point Q we need to know the surface normal and principal c...">calcParaboloid()</a> since it does not provide for a <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html" title="This object is used to hold precalculated data about the most recently accessed patch to accelerate t...">PatchHint</a>.  <a href="#afaa3bbd3a85c0a3c20198cc16b0a02ca">More...</a><br /></td></tr>
<tr class="separator:afaa3bbd3a85c0a3c20198cc16b0a02ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61a2268aa4d754d75074710ac97f901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#af61a2268aa4d754d75074710ac97f901">getNumPatches</a> (int &amp;nx, int &amp;ny) const </td></tr>
<tr class="memdesc:af61a2268aa4d754d75074710ac97f901"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Get the number of individual bicubic patches used to form this surface, as the dimensions along each side of a rectangular grid.  <a href="#af61a2268aa4d754d75074710ac97f901">More...</a><br /></td></tr>
<tr class="separator:af61a2268aa4d754d75074710ac97f901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a02ff972c4c1f7a0fa4eb1581fac5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Geo.html#ae66df3a039489bdc4b9a350a111bcf85">Geo::BicubicHermitePatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a5a02ff972c4c1f7a0fa4eb1581fac5c4">calcHermitePatch</a> (int x, int y) const </td></tr>
<tr class="memdesc:a5a02ff972c4c1f7a0fa4eb1581fac5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Select a patch by its (x,y) position in the rectangular grid of individual bicubic patches from which this surface is constructed, returning it as a Hermite patch.  <a href="#a5a02ff972c4c1f7a0fa4eb1581fac5c4">More...</a><br /></td></tr>
<tr class="separator:a5a02ff972c4c1f7a0fa4eb1581fac5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446d1a8d5810bb20f77941786153b2ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Geo.html#aa6ac161f679ff70829ff07ef7d632ee9">Geo::BicubicBezierPatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a446d1a8d5810bb20f77941786153b2ac">calcBezierPatch</a> (int x, int y) const </td></tr>
<tr class="memdesc:a446d1a8d5810bb20f77941786153b2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Select a patch by its (x,y) position in the rectangular grid of individual bicubic patches from which this surface is constructed, returning it as a Bezier patch.  <a href="#a446d1a8d5810bb20f77941786153b2ac">More...</a><br /></td></tr>
<tr class="separator:a446d1a8d5810bb20f77941786153b2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bookkeeping</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section are administrative and most users will not need to use them.</p>
</div></td></tr>
<tr class="memitem:a362ecf8e475831a8a370474ab958271b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a362ecf8e475831a8a370474ab958271b">isEmpty</a> () const </td></tr>
<tr class="memdesc:a362ecf8e475831a8a370474ab958271b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this is an empty handle meaning that it does not currently refer to any surface.  <a href="#a362ecf8e475831a8a370474ab958271b">More...</a><br /></td></tr>
<tr class="separator:a362ecf8e475831a8a370474ab958271b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cda5aaffdbf64aef0da2f99da142090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1BicubicSurface.html#a3cda5aaffdbf64aef0da2f99da142090">clear</a> ()</td></tr>
<tr class="memdesc:a3cda5aaffdbf64aef0da2f99da142090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this handle to its default-constructed state, meaning that it will not refer to any surface.  <a href="#a3cda5aaffdbf64aef0da2f99da142090">More...</a><br /></td></tr>
<tr class="separator:a3cda5aaffdbf64aef0da2f99da142090"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class will create a smooth surface that approximates a two-argument function F(X,Y) from a given set of samples of that function on a rectangular grid with regular or irregular spacing. </p>
<p>This is useful both for function interpolation and to provide height-mapped terrain surfaces. See the related class <a class="el" href="classSimTK_1_1BicubicFunction.html" title="This is a two-argument Function built using a shared BicubicSurface and managing current state to opt...">BicubicFunction</a> if you need to satisfy the <a class="el" href="namespaceSimTK.html#a0802d357d8b06888b8a1bc35a78c715c" title="This typedef is used for the very common case that the return type of the Function object is Real...">SimTK::Function</a> interface. A single <a class="el" href="classSimTK_1_1BicubicSurface.html" title="This class will create a smooth surface that approximates a two-argument function F(X...">BicubicSurface</a> can be shared among multiple accessors and threads once constructed.</p>
<div class="image">
<img src="BicubicSurface1.png" alt="BicubicSurface1.png"/>
<div class="caption">
A single-patch bicubic surface</div></div>
<p> A bicubic surface interpolation is used to approximate the function between the sample points. That is desirable for simulation use because it is continuous up to the second derivative, providing smoothly varying first derivatives, and a very smooth surface. The third derivatives will be discontinuous between grid boundaries; all higher derivatives are zero.</p>
<p>The user need only provide two vectors x and y defining the sample points, and a matrix f that defines the value of the function at each sample (you can think of that as the height Z of the surface over the X-Y plane). If the samples along both axes are regularly spaced, x and y can be defined just by giving the spacing; otherwise, the sample locations are given explicitly.</p>
<h3>Usage</h3>
<p>The following code generates an unsmoothed and smoothed surface using a 3x4 grid of bicubic patches from a matrix of 4x5 irregularly-spaced sample points: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> Nx = 4, Ny = 5;</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> xData[Nx]    = { .1, 1, 2, 4 };</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> yData[Ny]    = { -3, -2, 0, 1, 3 };</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> fData[Nx*Ny] = { 1,   2,   3,   3,   2,</div><div class="line">                           1.1, 2.1, 3.1, 3.1, 2.1,</div><div class="line">                            1,   2,   7,   3,   2,</div><div class="line">                           1.2, 2.2, 3.2, 3.2, 2.2 };</div><div class="line"><span class="keyword">const</span> <a class="code" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> x(Nx,    xData);</div><div class="line"><span class="keyword">const</span> <a class="code" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> y(Ny,    yData);</div><div class="line"><span class="keyword">const</span> <a class="code" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> f(Nx,Ny, fData);</div><div class="line"><a class="code" href="classSimTK_1_1BicubicSurface.html#aa008066f4580100b06fdd8295575e1ae">BicubicSurface</a> surfaceThroughSamples(x, y, f);</div><div class="line"><a class="code" href="classSimTK_1_1BicubicSurface.html#aa008066f4580100b06fdd8295575e1ae">BicubicSurface</a> smoothedSurface(x, y, f, 1); </div><div class="line"></div><div class="line"><span class="comment">// Evaluate the surface at (.5,.5):</span></div><div class="line"><a class="code" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> val = smoothedSurface.calcValue(<a class="code" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>(.5,.5));</div></div><!-- fragment --><p>When accessing the surface repeatedly, you can significantly improve performance by maintaining a "hint" object that allows for very fast repeated access to the same patch, a very common access pattern. Alternatively, use a <a class="el" href="classSimTK_1_1BicubicFunction.html" title="This is a two-argument Function built using a shared BicubicSurface and managing current state to opt...">BicubicFunction</a> as the interface to your <a class="el" href="classSimTK_1_1BicubicSurface.html" title="This class will create a smooth surface that approximates a two-argument function F(X...">BicubicSurface</a>; in that case the hint is managed for you automatically. Here is an example of explicit hint usage: </p><div class="fragment"><div class="line">PatchHint hint;</div><div class="line">val = smoothedSurface.calcValue(<a class="code" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>(.5,.6), hint);</div><div class="line">val = smoothedSurface.calcValue(<a class="code" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>(.51,.61), hint);</div></div><!-- fragment --><p>Additional methods are provided for obtaining the surface normals, and all the surface partial derivatives. Advanced users can obtain principal curvature directions, and performance statistics, among other specialized functions.</p>
<p>If you want to visualize the surface, you can ask it to generate a polygonal mesh (with optional control over the resolution). That mesh can be used to generate a <a class="el" href="classSimTK_1_1DecorativeMesh.html" title="This defines a displayable mesh by referencing an already-existing PolygonalMesh object. ">DecorativeMesh</a> compatible with the Simbody <a class="el" href="classSimTK_1_1Visualizer.html" title="Provide simple visualization of and interaction with a Simbody simulation, with real time control of ...">Visualizer</a>. This example creates a mesh of the smoothed surface, then places it on the Ground body so that the <a class="el" href="classSimTK_1_1Visualizer.html" title="Provide simple visualization of and interaction with a Simbody simulation, with real time control of ...">Visualizer</a> will pick it up. </p><div class="fragment"><div class="line">PolygonalMesh smoothedMesh = smoothedSurface.createPolygonalMesh();</div><div class="line">matter.Ground().addBodyDecoration(<a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>(0), <span class="comment">// place at origin</span></div><div class="line">    DecorativeMesh(smoothedMesh)</div><div class="line">        .setRepresentation(DecorativeGeometry::Wireframe)</div><div class="line">        .setColor(<a class="code" href="namespaceSimTK.html#a3b0c2aa41d7d89bb42b875c8b17b9269">Blue</a>));</div></div><!-- fragment --><h3>Discussion</h3>
<p>Graphically if the defining sample vectors and matrices were laid next to each other consistently with how the surface is computed the diagram would look like this: </p><pre>
             y(0)       y(1)    ...   y(ny-1)
            ------     ------         --------
    x(0)  |  f(0,0)     f(0,1)  ...   f(0,ny-1)
    x(1)  |  f(1,0)     f(1,1)  ...   f(1,ny-1)
     .    |    .          .              .
     .    |    .          .              .
     .    |    .          .              .
  x(nx-1) | f(nx-1,0)  f(nx-1,1)    f(nx-1,ny-1)
</pre><p> such that f(i,j)=F(x(i),y(j)).</p>
<p>Note that the each XY location can only have a unique value associated with it &ndash; cave-like structures cannot be represented using this interpolation method.</p>
<p>A bicubic surface interpolation requires the partial derivatives fx=Df/Dx, fy=Df/Dy and fxy=Dfx/Dy=D^2f/DxDy at each of the grid points. If you already know those, you can provide them directly. However, in most cases you will only know the sample points and not the derivatives. You can provide just the sample points and <a class="el" href="classSimTK_1_1BicubicSurface.html" title="This class will create a smooth surface that approximates a two-argument function F(X...">BicubicSurface</a> will estimate the derivatives automatically. For the interested reader, these partial derivatives are computed by fitting splines through the points provided, and then taking derivatives of splines.</p>
<p>These splines will pass through the points exactly when the smoothness parameter of the surface is set to 0, and will be interpolated using natural cubic splines, meaning that the curvature will be zero at the boundaries. When the smoothness parameter is greater than zero, the surface will be "relaxed" using the algorithm provided by <a class="el" href="classSimTK_1_1SplineFitter.html" title="Given a set of data points, this class creates a Spline_ which interpolates or approximates them...">SplineFitter</a>, and will not exactly pass through the points given, but will smoothly come close to the points. The smoothness parameter can thus be used to generate a surface that smoothly interpolates noisy surface data.</p>
<p>Here is a Wikipedia entry that describes the basic approach: <a href="http://en.wikipedia.org/wiki/Bicubic_interpolation">http://en.wikipedia.org/wiki/Bicubic_interpolation</a></p>
<dl class="section author"><dt>Author</dt><dd>Matthew Millard, Michael Sherman</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SplineFitter.html" title="Given a set of data points, this class creates a Spline_ which interpolates or approximates them...">SplineFitter</a> for implementation notes regarding smoothing. </dd>
<dd>
<a class="el" href="classSimTK_1_1BicubicFunction.html" title="This is a two-argument Function built using a shared BicubicSurface and managing current state to opt...">BicubicFunction</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa008066f4580100b06fdd8295575e1ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::BicubicSurface::BicubicSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an uninitialized <a class="el" href="classSimTK_1_1BicubicSurface.html" title="This class will create a smooth surface that approximates a two-argument function F(X...">BicubicSurface</a> handle. </p>
<p>This can be filled in later by assignment. </p>

</div>
</div>
<a class="anchor" id="ac74dc99f9f114096cd903a509f938f65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::BicubicSurface::~BicubicSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor deletes the underlying surface if there are no more handles referencing it, otherwise does nothing. </p>

</div>
</div>
<a class="anchor" id="a5dd80198bbcc78bb0fd9b8e79b1a0e9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::BicubicSurface::BicubicSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1BicubicSurface.html">BicubicSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor makes a shallow copy of <em>source</em>; the new handle will reference the same underlying surface as does <em>source</em>. </p>

</div>
</div>
<a class="anchor" id="a4eb540890a06e377b19171ca0b546316"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::BicubicSurface::BicubicSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>smoothness</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a bicubic surface that approximates F(X,Y) given samples f(i,j) with the sample locations in f defined by the vectors x and y. </p>
<p>The smoothness parameter controls how closely the surface approaches the grid points specified in matrix f, with the default being that the surface will pass exactly through those points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector of sample locations along the X axis (minimum 4 values). Must be monotonically increasing (no duplicates). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Vector of sample locations along the Y axis (minimum 4 values). Must be monotonically increasing (no duplicates). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Matrix of function values (or surface heights) evaluated at the grid points formed by x and y (dimension x.size() by y.size()), such that f(i,j) is F(x[i],y[j]) where F is the function being approximated here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smoothness</td><td>A value of 0 will force surface to pass through all of the points in f(x,y). As smoothness increases, the surface will become smoother and smoother but will increasingly deviate from the points stored in matrix <em>f</em>. (Optional, default is 0.)</td></tr>
  </table>
  </dd>
</dl>
<p>If your sample points are regularly spaced, use the other constructor. </p>

</div>
</div>
<a class="anchor" id="ae9dd87906575e90279703addf61f4c80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::BicubicSurface::BicubicSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>smoothness</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a bicubic surface that approximates F(X,Y) given samples f(i,j) over a grid with regular spacing in both the x and y directions. </p>
<p>The smoothness parameter controls how closely the surface approaches the grid points specified in matrix f, with the default being that the surface will pass exactly through those points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">XY</td><td>A Vec2 giving the (x0,y0) sample location associated with the (0,0) grid position in matrix <em>f</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacing</td><td>A Vec2 giving regular spacing along the x and y directions; both entries must be greater than 0. The (i,j)th sample location is then taken to be XY + (i*spacing[0], j*spacing[1]). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Matrix of function values (or surface heights) evaluated at points of the x-y plane regularly sampled using the supplied spacings. Can be rectangular but must have minimum dimension 4x4. Here f(i,j)=F(XY[0]+i*spacing[0],XY[1]+j*spacing[1]) where F is the function being approximated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smoothness</td><td>A value of 0 will force surface to pass through all of the points in <em>f</em>. As smoothness increases, the surface will become smoother and smoother but will increasingly deviate from the points stored in matrix <em>f</em>. (Optional, default is 0.)</td></tr>
  </table>
  </dd>
</dl>
<p>If your sample points are not regularly spaced, use the other constructor which allows for specified sample points. </p>

</div>
</div>
<a class="anchor" id="ac57d7ec45bed3a0914ec9a4e5f053bba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::BicubicSurface::BicubicSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>fy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>fxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) A constructor for a bicubic surface that sets the partial derivatives of the surface to the values specified by fx, fy, and fxy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>vector of X grid points (minimum 2 values) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>vector of Y grid points (minimum 2 values) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>matrix of the surface heights evaluated at the grid formed by x and y (minumum 2x2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fx</td><td>matrix of partial derivative of f w.r.t to x (minumum 2x2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fy</td><td>matrix of partial derivative of f w.r.t to y (minumum 2x2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fxy</td><td>matrix of partial derivative of f w.r.t to x,y (minumum 2x2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84c681c0997ea7f57896a4444a77e9cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::BicubicSurface::BicubicSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>fy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>fxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Same, but with regular grid spacing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a63513b6232cbf46b9d63e06afce82135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1BicubicSurface.html">BicubicSurface</a>&amp; SimTK::BicubicSurface::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1BicubicSurface.html">BicubicSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment is shallow; it makes this handle reference the same underlying surface as does <em>source</em>. </p>
<p>If this handle was currently referencing a different surface, that surface will be destructed if that was the last reference to it. </p>

</div>
</div>
<a class="anchor" id="a3c85895c61c9a54329e9782efe1c9a63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::BicubicSurface::calcValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html">PatchHint</a> &amp;&#160;</td>
          <td class="paramname"><em>hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value of the surface at a particular XY coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">XY</td><td>A Vec2 giving the (X,Y) point at which F(X,Y) is to be evaluated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hint</td><td>Information saved from an earlier invocation of <a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63" title="Calculate the value of the surface at a particular XY coordinate. ">calcValue()</a>, <a class="el" href="classSimTK_1_1BicubicSurface.html#a3be5d330c852f17455e01c3032af42b2" title="Calculate the outward unit normal to the surface at a particular XY coordinate. ">calcUnitNormal()</a>, or <a class="el" href="classSimTK_1_1BicubicSurface.html#ae4ebf00891ff7c736ca2d78bb4ed7eb4" title="Calculate a partial derivative of this function at a particular point. ">calcDerivative()</a> that is used to reduce execution time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated value of the function at point (X,Y).</dd></dl>
<p>Cost is minimal for repeated access to the same point, and considerably reduced if access is to the same patch. We also take advantage of a regularly-spaced grid if there is one to avoid searching for the right patch. </p>

</div>
</div>
<a class="anchor" id="a555d0b83780db1ca30104e8c33799c3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::BicubicSurface::calcValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a slow-but-convenient version of <a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63" title="Calculate the value of the surface at a particular XY coordinate. ">calcValue()</a> since it does not provide for a <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html" title="This object is used to hold precalculated data about the most recently accessed patch to accelerate t...">PatchHint</a>. </p>
<p>See the other signature for a much faster version. </p>

</div>
</div>
<a class="anchor" id="a3be5d330c852f17455e01c3032af42b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> SimTK::BicubicSurface::calcUnitNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html">PatchHint</a> &amp;&#160;</td>
          <td class="paramname"><em>hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the outward unit normal to the surface at a particular XY coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">XY</td><td>A Vec2 giving the (X,Y) point at which the normal is to be evaluated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hint</td><td>Information saved from an earlier invocation of <a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63" title="Calculate the value of the surface at a particular XY coordinate. ">calcValue()</a>, <a class="el" href="classSimTK_1_1BicubicSurface.html#a3be5d330c852f17455e01c3032af42b2" title="Calculate the outward unit normal to the surface at a particular XY coordinate. ">calcUnitNormal()</a>, or <a class="el" href="classSimTK_1_1BicubicSurface.html#ae4ebf00891ff7c736ca2d78bb4ed7eb4" title="Calculate a partial derivative of this function at a particular point. ">calcDerivative()</a> that is used to reduce execution time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The outward unit normal at point (X,Y).</dd></dl>
<p>This requires evaluating the first derivatives of the patch, constructing tangents, finding their cross product and normalizing. </p>

</div>
</div>
<a class="anchor" id="ab10acda40add5193fd5fc85f9c485774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> SimTK::BicubicSurface::calcUnitNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a slow-but-convenient version of <a class="el" href="classSimTK_1_1BicubicSurface.html#a3be5d330c852f17455e01c3032af42b2" title="Calculate the outward unit normal to the surface at a particular XY coordinate. ">calcUnitNormal()</a> since it does not provide for a <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html" title="This object is used to hold precalculated data about the most recently accessed patch to accelerate t...">PatchHint</a>. </p>
<p>See the other signature for a much faster version. </p>

</div>
</div>
<a class="anchor" id="ae4ebf00891ff7c736ca2d78bb4ed7eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::BicubicSurface::calcDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html">PatchHint</a> &amp;&#160;</td>
          <td class="paramname"><em>hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a partial derivative of this function at a particular point. </p>
<p>Which derivative to take is specified by listing the input components (0==x, 1==y) with which to take it. For example, if derivComponents=={0}, that indicates a first derivative with respective to argument x. If derivComponents=={0, 0, 0}, that indicates a third derivative with respective to argument x. If derivComponents=={0, 1}, that indicates a partial second derivative with respect to x and y, that is Df(x,y)/DxDy. (We use capital D to indicate partial derivative.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">derivComponents</td><td>The input components with respect to which the derivative should be taken. Its size must be less than or equal to the value returned by getMaxDerivativeOrder(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">XY</td><td>The vector of two input arguments that define the XY location on the surface. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hint</td><td>Information saved from an earlier invocation of <a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63" title="Calculate the value of the surface at a particular XY coordinate. ">calcValue()</a>, <a class="el" href="classSimTK_1_1BicubicSurface.html#a3be5d330c852f17455e01c3032af42b2" title="Calculate the outward unit normal to the surface at a particular XY coordinate. ">calcUnitNormal()</a>, or <a class="el" href="classSimTK_1_1BicubicSurface.html#ae4ebf00891ff7c736ca2d78bb4ed7eb4" title="Calculate a partial derivative of this function at a particular point. ">calcDerivative()</a> that is used to reduce execution time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated value of the selected function partial derivative for arguments (X,Y).</dd></dl>
<p>See comments in <a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63" title="Calculate the value of the surface at a particular XY coordinate. ">calcValue()</a> for a discussion of cost and how the hint is used to reduce the cost. </p>

</div>
</div>
<a class="anchor" id="aedf9739d4adbd415d664b3806f582508"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::BicubicSurface::calcDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a slow-but-convenient version of <a class="el" href="classSimTK_1_1BicubicSurface.html#ae4ebf00891ff7c736ca2d78bb4ed7eb4" title="Calculate a partial derivative of this function at a particular point. ">calcDerivative()</a> since it does not provide for a <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html" title="This object is used to hold precalculated data about the most recently accessed patch to accelerate t...">PatchHint</a>. </p>
<p>See the other signature for a much faster version. </p>

</div>
</div>
<a class="anchor" id="ac60a9f46a6546d318736ee120aaca9a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::BicubicSurface::isSurfaceDefined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The surface interpolation only works within the grid defined by the vectors x and y used in the constructor. </p>
<p>This function checks to see if an XYval is within the defined bounds of this particular <a class="el" href="classSimTK_1_1BicubicSurface.html" title="This class will create a smooth surface that approximates a two-argument function F(X...">BicubicSurface</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">XY</td><td>The vector of exactly 2 input arguments that define the XY location on the surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the point is in range, <code>false</code> otherwise.</dd></dl>
<p>An attempt to invoke <a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63" title="Calculate the value of the surface at a particular XY coordinate. ">calcValue()</a> or <a class="el" href="classSimTK_1_1BicubicSurface.html#ae4ebf00891ff7c736ca2d78bb4ed7eb4" title="Calculate a partial derivative of this function at a particular point. ">calcDerivative()</a> on an out-of-range point will raise an exception; use this method to check first if you are not sure. </p>

</div>
</div>
<a class="anchor" id="a646fd7a7126fc2ff3bc8cd32cb52555f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> SimTK::BicubicSurface::getMinXY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the lowest XY pair for which this surface is defined; that is the point (xmin,ymin). </p>

</div>
</div>
<a class="anchor" id="a1d7c415eb760219aaa3d35a0c621846b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> SimTK::BicubicSurface::getMaxXY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the highest XY pair for which this surface is defined; that is the point (xmax,ymax). </p>

</div>
</div>
<a class="anchor" id="ac977fe3869878e3755a57a77d6aeae89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> SimTK::BicubicSurface::createPolygonalMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mesh that can be used to visualize this surface. </p>
<p>The default resolution will generate four quads (2x2) per patch. Set <em>resolution</em> to the number of times you want each patch subdivided. The default is 1; set resolution=0 to get just one quad per patch, resolution=3 would give 16 quads (4x4) per patch.</p>
<p>The resulting mesh has its origin at (0,0,0), not at (x[0],y[0],0) as you might expect. X,Y,Z directions match the surface description. </p>

</div>
</div>
<a class="anchor" id="ab1866dc5bad498298394448d158a82ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::BicubicSurface::getNumAccesses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the total number of calls made to either <a class="el" href="classSimTK_1_1BicubicSurface.html#a3c85895c61c9a54329e9782efe1c9a63" title="Calculate the value of the surface at a particular XY coordinate. ">calcValue()</a> or <a class="el" href="classSimTK_1_1BicubicSurface.html#ae4ebf00891ff7c736ca2d78bb4ed7eb4" title="Calculate a partial derivative of this function at a particular point. ">calcDerivative()</a>. </p>

</div>
</div>
<a class="anchor" id="a508dd423a378bf14cbbef8bd9fc65db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::BicubicSurface::getNumAccessesSamePoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the number of accesses which specified a point whose information was already available in the hint. </p>
<p>Note that if different information is requested about the point, and that information is not already available, we count that as "same patch" but not "same point". These accesses are resolved with essentially no computation. </p>

</div>
</div>
<a class="anchor" id="a033a8e14d013727b53f2738d23d650bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::BicubicSurface::getNumAccessesSamePatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the number of accesses which specified a new point on the same patch as was already present in the hint, or asked for new information about the same point. </p>
<p>These accesses are resolved without having to search for the patch, and without having to compute patch information. However, specific point information still must be calculated. </p>

</div>
</div>
<a class="anchor" id="a478468ab44e8ec34ff7dbb74a8a5bb38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::BicubicSurface::getNumAccessesNearbyPatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the number of accesses which specified on a point that was not on the patch currently in the hint, but was close enough that we did not have to do a general search. </p>
<p>This also applies if the point is on an edge since those don't require searching either. So these accesses avoided searching, but still required patch and point information to be computed, which can be expensive. </p>

</div>
</div>
<a class="anchor" id="a9e25c46d3d03cc1cb652523fd2e2b98d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::BicubicSurface::resetStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset all statistics to zero. </p>
<p>Note that statistics are mutable so you do not have to have write access to the surface. Any user of this surface can reset statistics and we make no attempt to handle simultaneous access by multiple threads in any careful manner. </p>

</div>
</div>
<a class="anchor" id="a1127d93ae5897e00484a349540702631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::BicubicSurface::calcParaboloid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html">PatchHint</a> &amp;&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_SP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) For use with Hertz contact at a point Q we need to know the surface normal and principal curvature magnitudes and directions. </p>
<p>This can be viewed as an approximating paraboloid at Q in a frame P where OP=Q, Pz is the outward-facing unit normal to the surface at Q, Px is the direction of maximum curvature and Py is the direction of minimum curvature. k=(kmax,kmin) are the returned curvatures with kmax &gt;= kmin &gt; 0. The equation of the resulting paraboloid in the P frame is -2z = kmax*x^2 + kmin*y^2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">XY</td><td>The Vec2 that defines the desired location on the surface such that the contact point Q=F(X,Y). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hint</td><td>Information saved from an earlier invocation of this or another hint-using method in this class. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X_SP</td><td>The frame of the paraboloid P, measured and expressed in the surface local frame S. X_SP.p() is Q, X_SP.x() is the calculated direction of maximum curvature kmax; y() is the direction of minimum curvature kmin; z is the outward facing normal at Q. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">k</td><td>The maximum (k[0]) and minimum (k[1]) curvatures of the surface (and paraboloid P) at point Q. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afaa3bbd3a85c0a3c20198cc16b0a02ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::BicubicSurface::calcParaboloid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>XY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_SP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) This is a slow-but-convenient version of <a class="el" href="classSimTK_1_1BicubicSurface.html#a1127d93ae5897e00484a349540702631" title="(Advanced) For use with Hertz contact at a point Q we need to know the surface normal and principal c...">calcParaboloid()</a> since it does not provide for a <a class="el" href="classSimTK_1_1BicubicSurface_1_1PatchHint.html" title="This object is used to hold precalculated data about the most recently accessed patch to accelerate t...">PatchHint</a>. </p>
<p>See the other signature for a much faster version. </p>

</div>
</div>
<a class="anchor" id="af61a2268aa4d754d75074710ac97f901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::BicubicSurface::getNumPatches </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Get the number of individual bicubic patches used to form this surface, as the dimensions along each side of a rectangular grid. </p>
<p>There are nx X ny patches with indices in [0..nx-1, 0..ny-1]. </p>

</div>
</div>
<a class="anchor" id="a5a02ff972c4c1f7a0fa4eb1581fac5c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo.html#ae66df3a039489bdc4b9a350a111bcf85">Geo::BicubicHermitePatch</a> SimTK::BicubicSurface::calcHermitePatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Select a patch by its (x,y) position in the rectangular grid of individual bicubic patches from which this surface is constructed, returning it as a Hermite patch. </p>
<p>Cost is roughly 110 flops. </p>

</div>
</div>
<a class="anchor" id="a446d1a8d5810bb20f77941786153b2ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo.html#aa6ac161f679ff70829ff07ef7d632ee9">Geo::BicubicBezierPatch</a> SimTK::BicubicSurface::calcBezierPatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Select a patch by its (x,y) position in the rectangular grid of individual bicubic patches from which this surface is constructed, returning it as a Bezier patch. </p>
<p>Cost is roughly 330 flops. </p>

</div>
</div>
<a class="anchor" id="a362ecf8e475831a8a370474ab958271b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::BicubicSurface::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if this is an empty handle meaning that it does not currently refer to any surface. </p>
<p>This is the state the handle will have after default construction or a call to <a class="el" href="classSimTK_1_1BicubicSurface.html#a3cda5aaffdbf64aef0da2f99da142090" title="Return this handle to its default-constructed state, meaning that it will not refer to any surface...">clear()</a>. </p>

</div>
</div>
<a class="anchor" id="a3cda5aaffdbf64aef0da2f99da142090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::BicubicSurface::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return this handle to its default-constructed state, meaning that it will not refer to any surface. </p>
<p>If the handle was referencing some surface, and that was the last reference to that surface, then the surface will be destructed. After a call to <a class="el" href="classSimTK_1_1BicubicSurface.html#a3cda5aaffdbf64aef0da2f99da142090" title="Return this handle to its default-constructed state, meaning that it will not refer to any surface...">clear()</a>, <a class="el" href="classSimTK_1_1BicubicSurface.html#a362ecf8e475831a8a370474ab958271b" title="Return true if this is an empty handle meaning that it does not currently refer to any surface...">isEmpty()</a> will return <code>true</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BicubicSurface_8h_source.html">BicubicSurface.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1BicubicSurface.html">BicubicSurface</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:06 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
