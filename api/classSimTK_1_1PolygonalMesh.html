<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::PolygonalMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1PolygonalMesh.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classSimTK_1_1PolygonalMesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::PolygonalMesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class provides a description of a mesh made of polygonal faces (not limited to triangles).  
 <a href="classSimTK_1_1PolygonalMesh.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::PolygonalMesh:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1PolygonalMesh.png" usemap="#SimTK::PolygonalMesh_map" alt=""/>
  <map id="SimTK::PolygonalMesh_map" name="SimTK::PolygonalMesh_map">
<area href="classSimTK_1_1PIMPLHandle.html" alt="SimTK::PIMPLHandle&lt; PolygonalMesh, PolygonalMeshImpl, true &gt;" shape="rect" coords="0,0,390,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac330de389edb84d5b58883ee9bba660"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#aac330de389edb84d5b58883ee9bba660">PolygonalMesh</a> ()</td></tr>
<tr class="memdesc:aac330de389edb84d5b58883ee9bba660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty PolygonalMesh, with no vertices or faces.  <a href="#aac330de389edb84d5b58883ee9bba660">More...</a><br /></td></tr>
<tr class="separator:aac330de389edb84d5b58883ee9bba660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d11f81d7cd223541e46460b05acc60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a62d11f81d7cd223541e46460b05acc60">clear</a> ()</td></tr>
<tr class="memdesc:a62d11f81d7cd223541e46460b05acc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore this PolygonalMesh to its default-constructed state, meaning that it will contain no vertices or faces after this call.  <a href="#a62d11f81d7cd223541e46460b05acc60">More...</a><br /></td></tr>
<tr class="separator:a62d11f81d7cd223541e46460b05acc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ca5135b3fdeea0c6eed21b80fa48b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a68ca5135b3fdeea0c6eed21b80fa48b9">getNumFaces</a> () const </td></tr>
<tr class="memdesc:a68ca5135b3fdeea0c6eed21b80fa48b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces in the mesh.  <a href="#a68ca5135b3fdeea0c6eed21b80fa48b9">More...</a><br /></td></tr>
<tr class="separator:a68ca5135b3fdeea0c6eed21b80fa48b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75dee2df1e105d772f16db7234aad9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#ab75dee2df1e105d772f16db7234aad9e">getNumVertices</a> () const </td></tr>
<tr class="memdesc:ab75dee2df1e105d772f16db7234aad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertices in the mesh.  <a href="#ab75dee2df1e105d772f16db7234aad9e">More...</a><br /></td></tr>
<tr class="separator:ab75dee2df1e105d772f16db7234aad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d7ecd0264d2df9c957be97f6205584"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#aa7d7ecd0264d2df9c957be97f6205584">getVertexPosition</a> (int vertex) const </td></tr>
<tr class="memdesc:aa7d7ecd0264d2df9c957be97f6205584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of a vertex in the mesh.  <a href="#aa7d7ecd0264d2df9c957be97f6205584">More...</a><br /></td></tr>
<tr class="separator:aa7d7ecd0264d2df9c957be97f6205584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576269d858c2d3c2707c8a50ed2f78a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a576269d858c2d3c2707c8a50ed2f78a1">getNumVerticesForFace</a> (int face) const </td></tr>
<tr class="memdesc:a576269d858c2d3c2707c8a50ed2f78a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertices that make up a particular face.  <a href="#a576269d858c2d3c2707c8a50ed2f78a1">More...</a><br /></td></tr>
<tr class="separator:a576269d858c2d3c2707c8a50ed2f78a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8d9ffd70746fad4591c924fafd30be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a5b8d9ffd70746fad4591c924fafd30be">getFaceVertex</a> (int face, int vertex) const </td></tr>
<tr class="memdesc:a5b8d9ffd70746fad4591c924fafd30be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of one of the vertices of a face.  <a href="#a5b8d9ffd70746fad4591c924fafd30be">More...</a><br /></td></tr>
<tr class="separator:a5b8d9ffd70746fad4591c924fafd30be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe42b27d45d306bcc4bfca824fe329a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#affe42b27d45d306bcc4bfca824fe329a">addVertex</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;position)</td></tr>
<tr class="memdesc:affe42b27d45d306bcc4bfca824fe329a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex to the mesh.  <a href="#affe42b27d45d306bcc4bfca824fe329a">More...</a><br /></td></tr>
<tr class="separator:affe42b27d45d306bcc4bfca824fe329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fd6d1c18db6f92dea3e47112a64008"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a56fd6d1c18db6f92dea3e47112a64008">addFace</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;vertices)</td></tr>
<tr class="memdesc:a56fd6d1c18db6f92dea3e47112a64008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a face to the mesh.  <a href="#a56fd6d1c18db6f92dea3e47112a64008">More...</a><br /></td></tr>
<tr class="separator:a56fd6d1c18db6f92dea3e47112a64008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee89d84a08cdce5e4053f907c5be8ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a5ee89d84a08cdce5e4053f907c5be8ab">scaleMesh</a> (<a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> scale)</td></tr>
<tr class="memdesc:a5ee89d84a08cdce5e4053f907c5be8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a mesh by multiplying every vertex by a fixed value.  <a href="#a5ee89d84a08cdce5e4053f907c5be8ab">More...</a><br /></td></tr>
<tr class="separator:a5ee89d84a08cdce5e4053f907c5be8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883e60fbda837ef8a2426373b9f7e2c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a883e60fbda837ef8a2426373b9f7e2c1">transformMesh</a> (const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_AM)</td></tr>
<tr class="memdesc:a883e60fbda837ef8a2426373b9f7e2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a mesh by applying the given Transform to every vertex, leaving the mesh permanently changed.  <a href="#a883e60fbda837ef8a2426373b9f7e2c1">More...</a><br /></td></tr>
<tr class="separator:a883e60fbda837ef8a2426373b9f7e2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bfd0f4433593aaa4512ad9b6a63179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a15bfd0f4433593aaa4512ad9b6a63179">loadFile</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;pathname)</td></tr>
<tr class="memdesc:a15bfd0f4433593aaa4512ad9b6a63179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to interpret the given file as a mesh file, with the format determined from the file name extension.  <a href="#a15bfd0f4433593aaa4512ad9b6a63179">More...</a><br /></td></tr>
<tr class="separator:a15bfd0f4433593aaa4512ad9b6a63179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f262136030fdf977e1ef52541a4f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#aa8f262136030fdf977e1ef52541a4f3b">loadObjFile</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;pathname)</td></tr>
<tr class="memdesc:aa8f262136030fdf977e1ef52541a4f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a Wavefront OBJ (.obj) file, adding the vertices and faces it contains to this mesh, and ignoring anything else in the file.  <a href="#aa8f262136030fdf977e1ef52541a4f3b">More...</a><br /></td></tr>
<tr class="separator:aa8f262136030fdf977e1ef52541a4f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb5b67a2b9b157ef29566cd1e2c0f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a3fb5b67a2b9b157ef29566cd1e2c0f64">loadObjFile</a> (std::istream &amp;file)</td></tr>
<tr class="memdesc:a3fb5b67a2b9b157ef29566cd1e2c0f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for Wavefront OBJ format that takes an already-open istream rather than a pathname.  <a href="#a3fb5b67a2b9b157ef29566cd1e2c0f64">More...</a><br /></td></tr>
<tr class="separator:a3fb5b67a2b9b157ef29566cd1e2c0f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38a14ee7940a812219defc048ba7bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#aa38a14ee7940a812219defc048ba7bce">loadVtpFile</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;pathname)</td></tr>
<tr class="memdesc:aa38a14ee7940a812219defc048ba7bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a VTK PolyData (.vtp) file, adding the vertices and faces it contains to this mesh and ignoring anything else in the file.  <a href="#aa38a14ee7940a812219defc048ba7bce">More...</a><br /></td></tr>
<tr class="separator:aa38a14ee7940a812219defc048ba7bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283f29bac3e5d950d8d022d1da6ab300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a283f29bac3e5d950d8d022d1da6ab300">loadStlFile</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;pathname)</td></tr>
<tr class="memdesc:a283f29bac3e5d950d8d022d1da6ab300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an STL file, adding the vertices and faces it contains to this mesh and ignoring anything else in the file.  <a href="#a283f29bac3e5d950d8d022d1da6ab300">More...</a><br /></td></tr>
<tr class="separator:a283f29bac3e5d950d8d022d1da6ab300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1PIMPLHandle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1PIMPLHandle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle&lt; PolygonalMesh, PolygonalMeshImpl, true &gt;</a></td></tr>
<tr class="memitem:ab7d17772c38115b341ee2e12aeeac36f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#ab7d17772c38115b341ee2e12aeeac36f">isEmptyHandle</a> () const</td></tr>
<tr class="memdesc:ab7d17772c38115b341ee2e12aeeac36f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this handle is empty, that is, does not refer to any implementation object.  <a href="#ab7d17772c38115b341ee2e12aeeac36f">More...</a><br /></td></tr>
<tr class="separator:ab7d17772c38115b341ee2e12aeeac36f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6d9f8e49a5b828a9143b44a42e94f5 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a3a6d9f8e49a5b828a9143b44a42e94f5">isOwnerHandle</a> () const</td></tr>
<tr class="memdesc:a3a6d9f8e49a5b828a9143b44a42e94f5 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this handle is the owner of the implementation object to which it refers.  <a href="#a3a6d9f8e49a5b828a9143b44a42e94f5">More...</a><br /></td></tr>
<tr class="separator:a3a6d9f8e49a5b828a9143b44a42e94f5 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb05874b5a826344472105dbd649249 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a1cb05874b5a826344472105dbd649249">isSameHandle</a> (const <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> &amp;other) const</td></tr>
<tr class="memdesc:a1cb05874b5a826344472105dbd649249 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the supplied handle is the same object as "this" PIMPLHandle.  <a href="#a1cb05874b5a826344472105dbd649249">More...</a><br /></td></tr>
<tr class="separator:a1cb05874b5a826344472105dbd649249 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fc78d673f2db6a98f3bb4cdf14fd2f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a53fc78d673f2db6a98f3bb4cdf14fd2f">disown</a> (<a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> &amp;newOwner)</td></tr>
<tr class="memdesc:a53fc78d673f2db6a98f3bb4cdf14fd2f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give up ownership of the implementation to an empty handle.  <a href="#a53fc78d673f2db6a98f3bb4cdf14fd2f">More...</a><br /></td></tr>
<tr class="separator:a53fc78d673f2db6a98f3bb4cdf14fd2f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878ec0d1cdd705d051a485a89c32f6e9 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a878ec0d1cdd705d051a485a89c32f6e9">referenceAssign</a> (const <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> &amp;source)</td></tr>
<tr class="memdesc:a878ec0d1cdd705d051a485a89c32f6e9 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Copy" assignment but with shallow (pointer) semantics.  <a href="#a878ec0d1cdd705d051a485a89c32f6e9">More...</a><br /></td></tr>
<tr class="separator:a878ec0d1cdd705d051a485a89c32f6e9 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de72469fd5f56985b944f696e9e79ae inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a2de72469fd5f56985b944f696e9e79ae">copyAssign</a> (const <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> &amp;source)</td></tr>
<tr class="memdesc:a2de72469fd5f56985b944f696e9e79ae inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is real copy assignment, with ordinary C++ object ("value") semantics.  <a href="#a2de72469fd5f56985b944f696e9e79ae">More...</a><br /></td></tr>
<tr class="separator:a2de72469fd5f56985b944f696e9e79ae inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a485a9ef857781b8029ffd829fa636 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a46a485a9ef857781b8029ffd829fa636">clearHandle</a> ()</td></tr>
<tr class="memdesc:a46a485a9ef857781b8029ffd829fa636 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this an empty handle, deleting the implementation object if this handle is the owner of it.  <a href="#a46a485a9ef857781b8029ffd829fa636">More...</a><br /></td></tr>
<tr class="separator:a46a485a9ef857781b8029ffd829fa636 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66906a41755f8dae64f3bd945b949c74 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">const PolygonalMeshImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a66906a41755f8dae64f3bd945b949c74">getImpl</a> () const</td></tr>
<tr class="memdesc:a66906a41755f8dae64f3bd945b949c74 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the implementation associated with this Handle.  <a href="#a66906a41755f8dae64f3bd945b949c74">More...</a><br /></td></tr>
<tr class="separator:a66906a41755f8dae64f3bd945b949c74 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cea00ca400bace6ccb795e5ba54d4ef inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">PolygonalMeshImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a3cea00ca400bace6ccb795e5ba54d4ef">updImpl</a> ()</td></tr>
<tr class="memdesc:a3cea00ca400bace6ccb795e5ba54d4ef inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a writable reference to the implementation associated with this Handle.  <a href="#a3cea00ca400bace6ccb795e5ba54d4ef">More...</a><br /></td></tr>
<tr class="separator:a3cea00ca400bace6ccb795e5ba54d4ef inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e940afd133cc244c156b54a177529bd inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a0e940afd133cc244c156b54a177529bd">getImplHandleCount</a> () const</td></tr>
<tr class="memdesc:a0e940afd133cc244c156b54a177529bd inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of handles the implementation believes are referencing it.  <a href="#a0e940afd133cc244c156b54a177529bd">More...</a><br /></td></tr>
<tr class="separator:a0e940afd133cc244c156b54a177529bd inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0b962555490e190b9b86aff5daa4c3a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a0b962555490e190b9b86aff5daa4c3a6">createSphereMesh</a> (<a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> radius, int resolution=1)</td></tr>
<tr class="memdesc:a0b962555490e190b9b86aff5daa4c3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sphere-shaped mesh, with roughly uniform mesh elements.  <a href="#a0b962555490e190b9b86aff5daa4c3a6">More...</a><br /></td></tr>
<tr class="separator:a0b962555490e190b9b86aff5daa4c3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1906cc4855972d1862ba166aa15dcf0f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a1906cc4855972d1862ba166aa15dcf0f">createBrickMesh</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;halfDims, int resolution=1)</td></tr>
<tr class="memdesc:a1906cc4855972d1862ba166aa15dcf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a brick-shaped mesh.  <a href="#a1906cc4855972d1862ba166aa15dcf0f">More...</a><br /></td></tr>
<tr class="separator:a1906cc4855972d1862ba166aa15dcf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230bdd061c57b20cbe951ab8b0a939d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PolygonalMesh.html#a230bdd061c57b20cbe951ab8b0a939d3">createCylinderMesh</a> (const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;axis, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> radius, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> halfLength, int resolution=1)</td></tr>
<tr class="memdesc:a230bdd061c57b20cbe951ab8b0a939d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cylinder-shaped mesh, with the long axis in a given direction.  <a href="#a230bdd061c57b20cbe951ab8b0a939d3">More...</a><br /></td></tr>
<tr class="separator:a230bdd061c57b20cbe951ab8b0a939d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1PIMPLHandle"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1PIMPLHandle')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle&lt; PolygonalMesh, PolygonalMeshImpl, true &gt;</a></td></tr>
<tr class="memitem:a6b925b77482930c9ef55955fa1e48b45 inherit pub_types_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a>&lt; <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a>, PolygonalMeshImpl, PTR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a6b925b77482930c9ef55955fa1e48b45">HandleBase</a></td></tr>
<tr class="separator:a6b925b77482930c9ef55955fa1e48b45 inherit pub_types_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31b0b3d07fe975bdbeb5c1642e8e9c8 inherit pub_types_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1PIMPLHandle.html#a6b925b77482930c9ef55955fa1e48b45">HandleBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#ae31b0b3d07fe975bdbeb5c1642e8e9c8">ParentHandle</a></td></tr>
<tr class="separator:ae31b0b3d07fe975bdbeb5c1642e8e9c8 inherit pub_types_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSimTK_1_1PIMPLHandle"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSimTK_1_1PIMPLHandle')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle&lt; PolygonalMesh, PolygonalMeshImpl, true &gt;</a></td></tr>
<tr class="memitem:ae66aa14c4a664f31d22289e2bb604441 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#ae66aa14c4a664f31d22289e2bb604441">PIMPLHandle</a> ()</td></tr>
<tr class="memdesc:ae66aa14c4a664f31d22289e2bb604441 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor makes this an empty handle.  <a href="#ae66aa14c4a664f31d22289e2bb604441">More...</a><br /></td></tr>
<tr class="separator:ae66aa14c4a664f31d22289e2bb604441 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9451ca6b7502c54447d10449662a483 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#aa9451ca6b7502c54447d10449662a483">PIMPLHandle</a> (PolygonalMeshImpl *p)</td></tr>
<tr class="memdesc:aa9451ca6b7502c54447d10449662a483 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides consruction of a handle referencing an existing implementation object.  <a href="#aa9451ca6b7502c54447d10449662a483">More...</a><br /></td></tr>
<tr class="separator:aa9451ca6b7502c54447d10449662a483 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f661f13ccfd6ca41d8a9fc3435e32e7 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a6f661f13ccfd6ca41d8a9fc3435e32e7">PIMPLHandle</a> (const <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;source)</td></tr>
<tr class="memdesc:a6f661f13ccfd6ca41d8a9fc3435e32e7 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor makes either a deep (value) or shallow (reference) copy of the supplied source PIMPL object, based on whether this is a "pointer
semantics" (PTR=true) or "object (value) semantics" (PTR=false, default) class.  <a href="#a6f661f13ccfd6ca41d8a9fc3435e32e7">More...</a><br /></td></tr>
<tr class="separator:a6f661f13ccfd6ca41d8a9fc3435e32e7 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cabb439c294d4b696f9ec0a9534b6e3 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a5cabb439c294d4b696f9ec0a9534b6e3">~PIMPLHandle</a> ()</td></tr>
<tr class="memdesc:a5cabb439c294d4b696f9ec0a9534b6e3 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note that the destructor is non-virtual.  <a href="#a5cabb439c294d4b696f9ec0a9534b6e3">More...</a><br /></td></tr>
<tr class="separator:a5cabb439c294d4b696f9ec0a9534b6e3 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c83a6a5f2b7fb96834981442d30f8d inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a39c83a6a5f2b7fb96834981442d30f8d">operator=</a> (const <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;source)</td></tr>
<tr class="memdesc:a39c83a6a5f2b7fb96834981442d30f8d inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment makes the current handle either a deep (value) or shallow (reference) copy of the supplied source PIMPL object, based on whether this is a "pointer sematics" (PTR=true) or "object (value) semantics" (PTR=false, default) class.  <a href="#a39c83a6a5f2b7fb96834981442d30f8d">More...</a><br /></td></tr>
<tr class="separator:a39c83a6a5f2b7fb96834981442d30f8d inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59892732781a567f4ad30b982acb2c27 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a59892732781a567f4ad30b982acb2c27">setImpl</a> (PolygonalMeshImpl *p)</td></tr>
<tr class="memdesc:a59892732781a567f4ad30b982acb2c27 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the implementation for this empty handle.  <a href="#a59892732781a567f4ad30b982acb2c27">More...</a><br /></td></tr>
<tr class="separator:a59892732781a567f4ad30b982acb2c27 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3666ec4c8e626e771aa5d058605fa840 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a3666ec4c8e626e771aa5d058605fa840">hasSameImplementation</a> (const <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> &amp;other) const</td></tr>
<tr class="memdesc:a3666ec4c8e626e771aa5d058605fa840 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the supplied handle is a reference to the same implementation object as is referenced by "this" PIMPLHandle.  <a href="#a3666ec4c8e626e771aa5d058605fa840">More...</a><br /></td></tr>
<tr class="separator:a3666ec4c8e626e771aa5d058605fa840 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides a description of a mesh made of polygonal faces (not limited to triangles). </p>
<p>Its primary purpose is for loading geometry from files, which can then be used for visualization or collision detection. For example, the following lines load a mesh from a Wavefront OBJ file, then create a <a class="el" href="classSimTK_1_1DecorativeMesh.html" title="This defines a displayable mesh by referencing an already-existing PolygonalMesh object. ">DecorativeMesh</a> from it. </p><div class="fragment"><div class="line"><a class="code" href="classSimTK_1_1PolygonalMesh.html#aac330de389edb84d5b58883ee9bba660">PolygonalMesh</a> mesh;</div><div class="line">mesh.loadObjFile(<span class="stringliteral">&quot;teapot.obj&quot;</span>);</div><div class="line">DecorativeMesh decoration(mesh);</div></div><!-- fragment --><p> You can also read a polygon mesh from a VTK PolyData (.vtp) file, or an STL file (.stl) that is in ascii or binary format. You can also build meshes programmatically, and some static methods are provided here for generating some common shapes. If you don't know what kind of file you have, you can attempt to read it with the <a class="el" href="classSimTK_1_1PolygonalMesh.html#a15bfd0f4433593aaa4512ad9b6a63179" title="Attempt to interpret the given file as a mesh file, with the format determined from the file name ext...">loadFile()</a> method which will examine the file extension to determine the expected format.</p>
<p>The mesh has its own local frame and vertex locations are given in that frame. You can scale and transform the vertices relative to that frame (changing the values stored in the mesh) but more commonly the mesh will be placed on a body relative to that body's frame, meaning you can re-use the same mesh in various places.</p>
<p>We expect this to be a large object so give it shared (reference) semantics; that is, the copy constructor and copy assignment default to shallow copies (both handles will refer to the same data). If you want to make a deep (non-shared) copy of a <a class="el" href="classSimTK_1_1PolygonalMesh.html" title="This class provides a description of a mesh made of polygonal faces (not limited to triangles)...">PolygonalMesh</a>, use the <a class="el" href="classSimTK_1_1PIMPLHandle.html#a2de72469fd5f56985b944f696e9e79ae" title="This is real copy assignment, with ordinary C++ object (&quot;value&quot;) semantics. ">copyAssign()</a> method provided by the <a class="el" href="classSimTK_1_1PIMPLHandle.html" title="This class provides some infrastructure useful in making SimTK Private Implementation (PIMPL) classes...">PIMPLHandle</a> base class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aac330de389edb84d5b58883ee9bba660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::PolygonalMesh::PolygonalMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty PolygonalMesh, with no vertices or faces. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0b962555490e190b9b86aff5daa4c3a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> SimTK::PolygonalMesh::createSphereMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a sphere-shaped mesh, with roughly uniform mesh elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The radius of the underlying sphere. Vertices of the mesh will be on the sphere, with mesh elements somewhat inside. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>Control for how dense a mesh to produce. Resolution 0 will produce an octahedron (8 triangular faces). Resolution 1 (the default) gives 32 faces, resolution 2 gives 128. In general for resolution n there will be 2*4^(n+1) faces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A PolygonalMesh representing a sphere of the specified radius. </dd></dl>

</div>
</div>
<a class="anchor" id="a1906cc4855972d1862ba166aa15dcf0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> SimTK::PolygonalMesh::createBrickMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>halfDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a brick-shaped mesh. </p>
<p>A brick is a rectangular solid (a box) centered at and aligned with the mesh local frame. Note that its size is given with <em>half</em> dimensions. By default you will just get two mesh faces along the longest edge of the brick, with all other edges roughly the same size. You can control the mesh density with the <em>resolution</em> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">halfDims</td><td>The half-dimensions of the brick. The extreme vertices are at -halfDims and +halfDims, so the brick is centered around the mesh local frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>Control for how dense a mesh to produce. For this shape, <em>resolution</em> is interpreted as the number of extra vertices to insert in the <em>longest</em> edge of the brick. Extra vertices are inserted into the shorter edges if needed to keep the edge lengths approximately uniform for every mesh face. <em>resolution=0</em> gives only vertices at the corners; the default is 1 meaning that the longest edge is split once. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A PolygonalMesh representing a brick of the requested size.</dd></dl>
<h3>Controlling the mesh density:</h3>
<p>If you want a brick mesh where all the edges in the mesh are roughly the same length, say <code>wantEdgeLength</code>, set <em>resolution</em> like this: </p><div class="fragment"><div class="line"><a class="code" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> wantEdgeLength = ...;</div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> halfDims = ...;</div><div class="line"><span class="keywordtype">int</span> resolution = (int)(<a class="code" href="namespaceSimTK.html#a5e54f17d86aeb08126d641bea4ba6f86">max</a>(halfDims)/wantEdgeLength + 0.5);</div></div><!-- fragment --><p>If you want a brick mesh where all the edges are roughly the same length as the shortest edge of the brick, just set <code>wantEdgeLength=min(halfDims)</code> in the above calculation. </p>

</div>
</div>
<a class="anchor" id="a230bdd061c57b20cbe951ab8b0a939d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> SimTK::PolygonalMesh::createCylinderMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>halfLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a cylinder-shaped mesh, with the long axis in a given direction. </p>
<p>By default you'll get a 12 sided polygon as the base and elements of roughly similar dimension along the edges. You can control the mesh density with the <em>resolution</em> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>The central axis direction of the cylinder, in the mesh local frame. This can be provided using the constants XAxis, YAxis, or ZAxis, or you can provide a unit vector in any direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The cylinder radius. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">halfLength</td><td>Half the length of the cylinder along its axis. The bases are at -halfLength and +halfLength along the <em>axis</em>, so the cylinder is centered around the mesh local frame origin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>Control for how dense a mesh to produce (see below for details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A PolygonalMesh representing a cylinder of the requested dimensions and orientation.</dd></dl>
<h3>Controlling the mesh density:</h3>
<p>At resolution 0 the base is a hexagon with six triangular faces, and the tube is meshed with quad faces that are about as long as the diameter of the base. Resolution 1 (the default) makes the base a 12-sided polygon and introduces an intermediate 12-sided polygon of have the diameter. There will be triangles in the center still, but quad faces between the polygons. The length of the tube faces will be reduced to match. Higher resolutions refine the mesh similarly. </p>

</div>
</div>
<a class="anchor" id="a62d11f81d7cd223541e46460b05acc60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::PolygonalMesh::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore this PolygonalMesh to its default-constructed state, meaning that it will contain no vertices or faces after this call. </p>

</div>
</div>
<a class="anchor" id="a68ca5135b3fdeea0c6eed21b80fa48b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::PolygonalMesh::getNumFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of faces in the mesh. </p>

</div>
</div>
<a class="anchor" id="ab75dee2df1e105d772f16db7234aad9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::PolygonalMesh::getNumVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of vertices in the mesh. </p>

</div>
</div>
<a class="anchor" id="aa7d7ecd0264d2df9c957be97f6205584"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::PolygonalMesh::getVertexPosition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the position of a vertex in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The index of the vertex (as returned by <a class="el" href="classSimTK_1_1PolygonalMesh.html#affe42b27d45d306bcc4bfca824fe329a" title="Add a vertex to the mesh. ">addVertex()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the specified vertex, measured and expressed in the mesh local frame. </dd></dl>

</div>
</div>
<a class="anchor" id="a576269d858c2d3c2707c8a50ed2f78a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::PolygonalMesh::getNumVerticesForFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of vertices that make up a particular face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of the face (as returned by <a class="el" href="classSimTK_1_1PolygonalMesh.html#a56fd6d1c18db6f92dea3e47112a64008" title="Add a face to the mesh. ">addFace()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b8d9ffd70746fad4591c924fafd30be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::PolygonalMesh::getFaceVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of one of the vertices of a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of the face (as returned by <a class="el" href="classSimTK_1_1PolygonalMesh.html#a56fd6d1c18db6f92dea3e47112a64008" title="Add a face to the mesh. ">addFace()</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The index of the vertex within the face (from 0, 1, or 2 for a triangular face, etc.) These are ordered the same way as when the face was defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the specified vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="affe42b27d45d306bcc4bfca824fe329a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::PolygonalMesh::addVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a vertex to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position of the vertex to add, measured and expressed in the mesh local frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the newly added vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="a56fd6d1c18db6f92dea3e47112a64008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::PolygonalMesh::addFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a face to the mesh. </p>
<p>Note that the ordering of the vertices defines the outward normal for the face; they must be counterclockwise around the desired normal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>Indices of the vertices which make up the new face, in counterclockwise order with respect to the face normal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the newly added face. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ee89d84a08cdce5e4053f907c5be8ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a>&amp; SimTK::PolygonalMesh::scaleMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale a mesh by multiplying every vertex by a fixed value. </p>
<p>Note that this permanently modifies the vertex locations within the mesh. Since the vertices are measured in the mesh local frame, scaling will appear to occur around the mesh origin (that is, the origin will remain where it was while everything else changes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale factor. Can be any value except zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this now-scaled mesh object. </dd></dl>

</div>
</div>
<a class="anchor" id="a883e60fbda837ef8a2426373b9f7e2c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a>&amp; SimTK::PolygonalMesh::transformMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_AM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a mesh by applying the given Transform to every vertex, leaving the mesh permanently changed. </p>
<p>This has the effect of replacing the mesh local frame M with a new frame A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X_AM</td><td>The transform giving the pose of the mesh local frame in the new frame A. Every vertex v_M becomes v_A=X_AM*v_M. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this now-transformed mesh object. </dd></dl>

</div>
</div>
<a class="anchor" id="a15bfd0f4433593aaa4512ad9b6a63179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::PolygonalMesh::loadFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to interpret the given file as a mesh file, with the format determined from the file name extension. </p>
<p>If we recognize the extension we'll call one of the specialized methods below; see the descriptions for more information. Ignoring case, we recognize:</p><ul>
<li><code>.obj </code>: Wavefront OBJ file</li>
<li><code>.stl </code>: 3D Systems Stereolithography file (ascii or binary)</li>
<li><code>.stla</code>: ascii-only stl extension</li>
<li><code>.vtp </code>: VTK PolyData file (we can only read the ascii version)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathname</td><td>The name of a mesh file with a recognized extension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8f262136030fdf977e1ef52541a4f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::PolygonalMesh::loadObjFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a Wavefront OBJ (.obj) file, adding the vertices and faces it contains to this mesh, and ignoring anything else in the file. </p>
<p>The suffix for these files is typically ".obj" but we don't check here. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathname</td><td>The name of a .obj file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fb5b67a2b9b157ef29566cd1e2c0f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::PolygonalMesh::loadObjFile </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate signature for Wavefront OBJ format that takes an already-open istream rather than a pathname. </p>
<p>This is useful for testing since it can be supplied by a stringstream rather than a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>An input stream from which to load the file contents. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa38a14ee7940a812219defc048ba7bce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::PolygonalMesh::loadVtpFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a VTK PolyData (.vtp) file, adding the vertices and faces it contains to this mesh and ignoring anything else in the file. </p>
<p>The suffix for these files is typically ".vtp" but we don't check here. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathname</td><td>The name of a .vtp file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a283f29bac3e5d950d8d022d1da6ab300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::PolygonalMesh::loadStlFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load an STL file, adding the vertices and faces it contains to this mesh and ignoring anything else in the file. </p>
<p>The file may be in ascii or binary format. If the suffix is ".stla" then it can only be ascii. Otherwise, including ".stl" or anything else, we'll examine the contents to determine which format is used. STL files include many repeated vertices; we will collapse any that coincide to within a small tolerance so that there is some hope of getting a connected surface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathname</td><td>The name of a .stl or .stla file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PolygonalMesh_8h_source.html">PolygonalMesh.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:22 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
